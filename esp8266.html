<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Monitor Dashboard</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .dashboard-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .device-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: none;
        }

        .device-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .device-card.offline-critical {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
            border: 2px solid #e74c3c;
            box-shadow: 0 4px 20px rgba(231, 76, 60, 0.3);
        }

        .device-card.offline-critical:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(231, 76, 60, 0.4);
        }

        .device-card.offline-critical .device-id {
            color: white;
        }

        .device-card.offline-critical .device-id i {
            color: #ffcccb;
        }

        .device-card.offline-critical .device-type {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .device-card.offline-critical .temp-reading {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .device-card.offline-critical .temp-label {
            color: #ffcccb;
        }

        .device-card.offline-critical .temp-value {
            color: white;
        }

        .device-card.offline-critical .ip-address {
            color: #ffcccb;
        }

        .device-card.offline-critical .last-update {
            color: #ffcccb;
        }

        .device-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e9ecef;
        }

        .device-id {
            font-size: 1.2rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .device-id i {
            margin-right: 0.5rem;
            color: #3498db;
        }

        .status-online {
            background-color: #27ae60;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .status-offline {
            background-color: #e74c3c;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .device-type {
            background-color: #ecf0f1;
            color: #2c3e50;
            padding: 0.25rem 0.75rem;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 1rem;
            display: inline-block;
        }

        .temp-reading {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding: 0.5rem;
            background-color: #f8f9fa;
            border-radius: 6px;
        }

        .temp-label {
            color: #6c757d;
            font-size: 0.9rem;
        }

        .temp-value {
            font-weight: 600;
            color: #2c3e50;
        }

        .temp-value.error {
            color: #e74c3c;
        }

        .temp-value.normal {
            color: #27ae60;
        }

        .temp-value.cold {
            color: #3498db;
        }

        .temp-value.optimal {
            color: #27ae60;
        }

        .temp-value.hot {
            color: #e74c3c;
        }

        .ip-address {
            color: #6c757d;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .last-update {
            color: #95a5a6;
            font-size: 0.8rem;
            text-align: right;
        }

        .stats-bar {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9rem;
        }

        .online-stat {
            color: #27ae60;
        }

        .offline-stat {
            color: #e74c3c;
        }
    </style>
</head>

<body>
    <div class="dashboard-header">
        <div class="container">
            <div class="row">
                <div class="col-12 text-center">
                    <h1 class="mb-0">
                        <i class="fas fa-thermometer-half me-3"></i>
                        Temperature Monitor Dashboard
                    </h1>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Statistics Bar -->
        <div class="stats-bar">
            <div class="row">
                <div class="col-md-2">
                    <div class="stat-item total-devices">
                        <div class="stat-number">8</div>
                        <div class="stat-label">Total Devices</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="stat-item online-devices">
                        <div class="stat-number online-stat">0</div>
                        <div class="stat-label">Online</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="stat-item offline-devices">
                        <div class="stat-number offline-stat">0</div>
                        <div class="stat-label">Offline</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="stat-item">
                        <button class="btn btn-primary btn-sm" onclick="queryLastTemperatures()" title="Query Latest Temperature Data">
                            <i class="fas fa-search me-2"></i>Query Temps
                        </button>
                        <div class="stat-label mt-1">
                            <small id="last-query-time">Never queried</small>
                        </div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="stat-item">
                        <button class="btn btn-danger btn-sm" onclick="generatePDFReport()" title="Export Last Report to PDF">
                            <i class="fas fa-file-pdf me-2"></i>Export PDF
                        </button>
                        <div class="stat-label mt-1">
                            <small class="text-info">
                                <i class="fas fa-download me-1"></i>Report
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Device Cards Container -->
        <div class="row" id="device-cards-container">
            <!-- Device cards will be dynamically generated here -->
            <div class="col-12 text-center">
                <div class="loading-message" style="padding: 3rem;">
                    <i class="fas fa-spinner fa-spin fa-2x text-primary mb-3"></i>
                    <h4>กำลังโหลดข้อมูลอุปกรณ์...</h4>
                    <p class="text-muted">กำลังเชื่อมต่อกับ Firebase และดึงรายการอุปกรณ์</p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getDatabase, ref, onValue, query, orderByChild, limitToLast } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-database.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBtj8Jl6tRJyRUef145AtGvSADh37xSVSs",
            authDomain: "tempsskh-f4318.firebaseapp.com",
            databaseURL: "https://tempsskh-f4318-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "tempsskh-f4318",
            storageBucket: "tempsskh-f4318.firebasestorage.app",
            messagingSenderId: "989516171136",
            appId: "1:989516171136:web:64cb3d46e3a546dd0c2365",
            measurementId: "G-97L0RL7NP7"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Add Firebase connection monitoring
        console.log('Firebase initialized successfully');
        console.log('Database URL:', firebaseConfig.databaseURL);
        console.log('Connecting to Firebase...');

        // Define the specific devices to monitor (will be populated from database)
        let deviceList = [];

        // Store device data and state
        const deviceData = {};
        let onlineCount = 0;
        let offlineCount = 0;
        
        // Data optimization settings (enhanced for latest data only)
        const DATA_OPTIMIZATION = {
            maxLogEntries: 20,        // Reduced from 50 to 20 - Keep only last 20 entries per device
            cleanupInterval: 600000,  // Increased to 10 minutes - Less frequent cleanup
            onlineThreshold: 300,     // 5 minutes in seconds - **CRITICAL: This determines online/offline status**
            maxDataAge: 43200,        // Reduced from 24 hours to 12 hours - Keep only recent data
            batchSize: 8,             // Reduced from 10 to 8 - Smaller batches
            useCompression: true,     // Enable data compression
            cacheTimeout: 120000,     // Increased to 2 minutes - Longer cache duration
            maxCacheSize: 100,        // Maximum cache entries
            useLatestDataOnly: true,  // Flag to ensure only latest data is used
            minQueryInterval: 30000   // Minimum 30 seconds between queries
        };

        console.log('⚙️  Current online threshold:', DATA_OPTIMIZATION.onlineThreshold, 'seconds (', Math.floor(DATA_OPTIMIZATION.onlineThreshold / 60), 'minutes )');

        // Cache for reducing duplicate queries
        const dataCache = new Map();
        
        // Listener references for cleanup
        const deviceListeners = new Map();

        // PDF generation functions
        let lastReportData = null;
        let lastReportGenerated = null;

        async function generatePDFReport() {
            try {
                // Show loading indicator
                const loadingToast = showToast('Generating PDF report...', 'info');
                
                // Use last report data if available, otherwise generate new report
                if (!lastReportData) {
                    showToast('No report data available. Please run "Query Temps" first.', 'warning');
                    return;
                }

                // Generate PDF with jsPDF
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                // Add title
                doc.setFontSize(20);
                doc.text('ESP8266 Temperature Monitoring Report', 20, 20);
                
                // Add generation timestamp
                doc.setFontSize(12);
                doc.text(`Generated: ${new Date().toLocaleString()}`, 20, 35);
                
                if (lastReportGenerated) {
                    doc.text(`Query Time: ${lastReportGenerated}`, 20, 45);
                }

                // Add summary statistics
                doc.setFontSize(14);
                doc.text('Summary Statistics:', 20, 60);
                doc.setFontSize(10);
                
                let yPos = 75;
                const stats = getReportStatistics();
                doc.text(`Total Devices: ${stats.totalDevices}`, 25, yPos);
                yPos += 10;
                doc.text(`Online Devices: ${stats.onlineDevices}`, 25, yPos);
                yPos += 10;
                doc.text(`Offline Devices: ${stats.offlineDevices}`, 25, yPos);
                yPos += 10;
                doc.text(`Critical Offline: ${stats.criticalOffline}`, 25, yPos);
                yPos += 10;
                doc.text(`Average Temperature 1: ${stats.avgTemp1}°C`, 25, yPos);
                yPos += 10;
                doc.text(`Average Temperature 2: ${stats.avgTemp2}°C`, 25, yPos);
                yPos += 10;
                doc.text(`Temperature 1 Range: ${stats.temp1Range.min}°C - ${stats.temp1Range.max}°C`, 25, yPos);
                yPos += 10;
                doc.text(`Temperature 2 Range: ${stats.temp2Range.min}°C - ${stats.temp2Range.max}°C`, 25, yPos);
                yPos += 20;

                // Add temperature classification report
                doc.setFontSize(14);
                doc.text('Temperature Classification:', 20, yPos);
                yPos += 10;
                doc.setFontSize(10);
                
                const tempClassification = getTemperatureClassificationReport();
                doc.text(`Temperature 1 - Cold (<2°C): ${tempClassification.temp1.cold} readings`, 25, yPos);
                yPos += 8;
                doc.text(`Temperature 1 - Optimal (2-8°C): ${tempClassification.temp1.optimal} readings`, 25, yPos);
                yPos += 8;
                doc.text(`Temperature 1 - Hot (>8°C): ${tempClassification.temp1.hot} readings`, 25, yPos);
                yPos += 8;
                doc.text(`Temperature 1 - Errors: ${tempClassification.temp1.error} readings`, 25, yPos);
                yPos += 12;
                doc.text(`Temperature 2 - Cold (<2°C): ${tempClassification.temp2.cold} readings`, 25, yPos);
                yPos += 8;
                doc.text(`Temperature 2 - Optimal (2-8°C): ${tempClassification.temp2.optimal} readings`, 25, yPos);
                yPos += 8;
                doc.text(`Temperature 2 - Hot (>8°C): ${tempClassification.temp2.hot} readings`, 25, yPos);
                yPos += 8;
                doc.text(`Temperature 2 - Errors: ${tempClassification.temp2.error} readings`, 25, yPos);
                yPos += 20;

                // Add device details
                doc.setFontSize(14);
                doc.text('Device Details:', 20, yPos);
                yPos += 10;
                doc.setFontSize(8);

                // Table headers - Updated for both temperatures
                doc.text('Device ID', 25, yPos);
                doc.text('Status', 65, yPos);
                doc.text('Temp1', 85, yPos);
                doc.text('Temp2', 110, yPos);
                doc.text('Last Update', 135, yPos);
                doc.text('IP Address', 170, yPos);
                yPos += 5;

                // Add line separator
                doc.line(20, yPos, 190, yPos);
                yPos += 5;

                // Add device data
                lastReportData.forEach(device => {
                    if (yPos > 270) { // Page break
                        doc.addPage();
                        yPos = 20;
                        // Re-add headers on new page
                        doc.setFontSize(8);
                        doc.text('Device ID', 25, yPos);
                        doc.text('Status', 65, yPos);
                        doc.text('Temp1', 85, yPos);
                        doc.text('Temp2', 110, yPos);
                        doc.text('Last Update', 135, yPos);
                        doc.text('IP Address', 170, yPos);
                        yPos += 5;
                        doc.line(20, yPos, 190, yPos);
                        yPos += 5;
                    }
                    
                    doc.text(device.deviceId, 25, yPos);
                    doc.text(device.status.toUpperCase(), 65, yPos);
                    
                    // Temperature 1
                    const temp1Text = device.temp1 !== null ? `${device.temp1.toFixed(2)}°C` : 'ERROR';
                    doc.text(temp1Text, 85, yPos);
                    
                    // Temperature 2
                    const temp2Text = device.temp2 !== null ? `${device.temp2.toFixed(2)}°C` : 'ERROR';
                    doc.text(temp2Text, 110, yPos);
                    
                    doc.text(device.lastUpdate || 'Never', 135, yPos);
                    doc.text(device.ip || 'N/A', 170, yPos);
                    yPos += 8;
                });

                // Add footer
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFontSize(8);
                    doc.text(`Page ${i} of ${pageCount}`, 170, 285);
                    doc.text('Generated by ESP8266 Temperature Monitor', 20, 285);
                }

                // Generate filename with timestamp
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const filename = `temperature-report-${timestamp}.pdf`;

                // Save PDF
                doc.save(filename);

                // Hide loading and show success
                showToast(`PDF report exported successfully: ${filename}`, 'success');

            } catch (error) {
                console.error('PDF generation error:', error);
                showToast('Error generating PDF report. Please try again.', 'error');
            }
        }

        function getReportStatistics() {
            if (!lastReportData) return {};
            
            const stats = {
                totalDevices: lastReportData.length,
                onlineDevices: 0,
                offlineDevices: 0,
                criticalOffline: 0,
                avgTemp1: 0,
                avgTemp2: 0,
                temp1Range: { min: Infinity, max: -Infinity },
                temp2Range: { min: Infinity, max: -Infinity },
                validTemp1: [],
                validTemp2: []
            };

            lastReportData.forEach(device => {
                if (device.status === 'online') {
                    stats.onlineDevices++;
                } else {
                    stats.offlineDevices++;
                    if (device.criticalOffline) {
                        stats.criticalOffline++;
                    }
                }

                // Process Temperature 1
                if (device.temp1 !== null && device.temp1 !== undefined) {
                    const temp1 = parseFloat(device.temp1);
                    if (!isNaN(temp1)) {
                        stats.validTemp1.push(temp1);
                        stats.temp1Range.min = Math.min(stats.temp1Range.min, temp1);
                        stats.temp1Range.max = Math.max(stats.temp1Range.max, temp1);
                    }
                }

                // Process Temperature 2
                if (device.temp2 !== null && device.temp2 !== undefined) {
                    const temp2 = parseFloat(device.temp2);
                    if (!isNaN(temp2)) {
                        stats.validTemp2.push(temp2);
                        stats.temp2Range.min = Math.min(stats.temp2Range.min, temp2);
                        stats.temp2Range.max = Math.max(stats.temp2Range.max, temp2);
                    }
                }
            });

            // Calculate averages
            if (stats.validTemp1.length > 0) {
                stats.avgTemp1 = (stats.validTemp1.reduce((a, b) => a + b, 0) / stats.validTemp1.length).toFixed(2);
            } else {
                stats.avgTemp1 = 'N/A';
                stats.temp1Range.min = 'N/A';
                stats.temp1Range.max = 'N/A';
            }

            if (stats.validTemp2.length > 0) {
                stats.avgTemp2 = (stats.validTemp2.reduce((a, b) => a + b, 0) / stats.validTemp2.length).toFixed(2);
            } else {
                stats.avgTemp2 = 'N/A';
                stats.temp2Range.min = 'N/A';
                stats.temp2Range.max = 'N/A';
            }

            return stats;
        }

        // Debug function to check Firebase connectivity
        function checkFirebaseConnection() {
            console.log('=== FIREBASE CONNECTION CHECK ===');
            console.log('Firebase Config:', firebaseConfig);
            console.log('Database URL:', firebaseConfig.databaseURL);
            
            // Test basic connectivity
            const testRef = ref(database, '.info/connected');
            onValue(testRef, (snapshot) => {
                const connected = snapshot.val();
                console.log('Firebase connected:', connected);
                
                if (connected) {
                    console.log('✅ Firebase connection is active');
                    
                    // Test reading from devices path
                    const devicesRef = ref(database, 'devices');
                    onValue(devicesRef, (snapshot) => {
                        const data = snapshot.val();
                        console.log('Devices data structure:', data);
                        
                        if (data) {
                            console.log('✅ Can read devices data');
                            console.log('Available devices:', Object.keys(data));
                            
                            // Check each device's log structure
                            Object.keys(data).forEach(deviceId => {
                                const deviceData = data[deviceId];
                                console.log(`Device ${deviceId}:`, deviceData);
                                
                                if (deviceData.log) {
                                    const logEntries = Object.values(deviceData.log);
                                    console.log(`  Log entries count: ${logEntries.length}`);
                                    
                                    // Find latest log entry
                                    let latest = null;
                                    let latestTimestamp = 0;
                                    
                                    logEntries.forEach(entry => {
                                        if (entry.timestamp && parseInt(entry.timestamp) > latestTimestamp) {
                                            latestTimestamp = parseInt(entry.timestamp);
                                            latest = entry;
                                        }
                                    });
                                    
                                    if (latest) {
                                        const age = Math.floor(Date.now() / 1000) - parseInt(latest.timestamp);
                                        console.log(`  Latest entry: ${new Date(latest.timestamp * 1000).toLocaleString()}`);
                                        console.log(`  Age: ${age} seconds (${Math.floor(age/60)}m ${age%60}s)`);
                                        console.log(`  Temperature 1: ${latest.temp1}°C`);
                                        console.log(`  Temperature 2: ${latest.temp2}°C`);
                                        console.log(`  Status: ${age < DATA_OPTIMIZATION.onlineThreshold ? 'ONLINE' : 'OFFLINE'}`);
                                    }
                                } else {
                                    console.log(`  ❌ No log data found for ${deviceId}`);
                                }
                            });
                        } else {
                            console.log('❌ No devices data found');
                        }
                    }, { once: true });
                } else {
                    console.log('❌ Firebase connection failed');
                }
            }, { once: true });
            
            console.log('===================================');
        }
        function showToast(message, type = 'info') {
            // Create toast container if not exists
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                toastContainer.style.position = 'fixed';
                toastContainer.style.top = '20px';
                toastContainer.style.right = '20px';
                toastContainer.style.zIndex = '9999';
                document.body.appendChild(toastContainer);
            }

            // Create toast element
            const toast = document.createElement('div');
            toast.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show`;
            toast.style.marginBottom = '10px';
            toast.style.minWidth = '300px';
            toast.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;

            // Add to container
            toastContainer.appendChild(toast);

            // Auto remove after 5 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 5000);

            return toast;
        }
        function createDeviceCard(deviceId) {
            const zone = deviceId.split('-')[0]; // Extract zone from device ID
            return `
                <div class="col-lg-3 col-md-6 mb-4">
                    <div class="device-card" data-device-id="${deviceId}">
                        <div class="device-header">
                            <div class="device-id">
                                <i class="fas fa-microchip"></i>
                                ${deviceId}
                            </div>
                            <span class="status-badge status-offline">กำลังโหลด...</span>
                        </div>
                        <div class="device-type">${zone}</div>
                        <div class="offline-duration" style="display: none;">
                            <small class="text-warning">
                                <i class="fas fa-clock me-1"></i>
                                <span class="duration-text">Offline for: -</span>
                            </small>
                        </div>
                        <div class="temp-reading">
                            <span class="temp-label">อุณหภูมิ 1:</span>
                            <span class="temp-value temp1-value">-</span>
                        </div>
                        <div class="temp-reading">
                            <span class="temp-label">อุณหภูมิ 2:</span>
                            <span class="temp-value temp2-value">-</span>
                        </div>
                        <div class="ip-address">
                            <i class="fas fa-network-wired me-2"></i>
                            IP Address: -
                        </div>
                        <div class="last-update">
                            อัปเดตล่าสุด: กำลังโหลด...
                        </div>
                    </div>
                </div>
            `;
        }

        // Function to render device cards
        function renderDeviceCards() {
            const container = document.getElementById('device-cards-container');
            const cardsHTML = deviceList.map(deviceId => createDeviceCard(deviceId)).join('');

            container.innerHTML = cardsHTML;

            // Add click handlers for device cards
            container.querySelectorAll('.device-card').forEach(card => {
                card.addEventListener('click', function () {
                    const deviceId = this.getAttribute('data-device-id');
                    console.log(`Clicked on device: ${deviceId}`, deviceData[deviceId]);
                });
            });
        }

        // Function to determine if device is online (data received within last 5 minutes)
        function isDeviceOnline(timestamp) {
            if (!timestamp) {
                console.warn('No timestamp provided for device online check');
                return false;
            }
            
            const now = Math.floor(Date.now() / 1000);
            const deviceTime = parseInt(timestamp);
            const timeDifference = now - deviceTime;
            
            // Debug logging
            console.log(`Device online check: Current time: ${now}, Device time: ${deviceTime}, Difference: ${timeDifference}s, Threshold: ${DATA_OPTIMIZATION.onlineThreshold}s`);
            
            const isOnline = timeDifference < DATA_OPTIMIZATION.onlineThreshold;
            console.log(`Device is ${isOnline ? 'ONLINE' : 'OFFLINE'} (${Math.floor(timeDifference / 60)}m ${timeDifference % 60}s ago)`);
            
            return isOnline;
        }

        // Function to determine if device is critically offline (over 30 minutes)
        function isDeviceCriticallyOffline(timestamp) {
            if (!timestamp) return true;
            const now = Math.floor(Date.now() / 1000);
            const deviceTime = parseInt(timestamp);
            const thirtyMinutes = 30 * 60; // 30 minutes in seconds
            return (now - deviceTime) > thirtyMinutes;
        }

        // Function to get offline duration in minutes
        function getOfflineDuration(timestamp) {
            if (!timestamp) return null;
            const now = Math.floor(Date.now() / 1000);
            const deviceTime = parseInt(timestamp);
            const durationSeconds = now - deviceTime;
            return Math.floor(durationSeconds / 60); // Return minutes
        }

        // Enhanced cache management for latest data only
        function isDataFresh(cacheKey) {
            const cached = dataCache.get(cacheKey);
            if (!cached) return false;
            
            const now = Date.now();
            const isStillFresh = (now - cached.timestamp) < DATA_OPTIMIZATION.cacheTimeout;
            
            // Log cache usage for monitoring
            if (isStillFresh) {
                console.log(`Cache hit for ${cacheKey} (${Math.round((now - cached.timestamp) / 1000)}s old)`);
            }
            
            return isStillFresh;
        }

        // Function to compress data object (remove unnecessary fields)
        function compressDeviceData(data) {
            if (!DATA_OPTIMIZATION.useCompression) return data;
            
            return {
                t1: data.temp1,           // temp1 -> t1
                t2: data.temp2,           // temp2 -> t2
                s1: data.status_temp1,    // status_temp1 -> s1
                s2: data.status_temp2,    // status_temp2 -> s2
                ip: data.ip,
                ts: data.timestamp,       // timestamp -> ts
                dt: data.datetime         // datetime -> dt (keep for display)
            };
        }

        // Function to decompress data object
        function decompressDeviceData(compressed) {
            if (!DATA_OPTIMIZATION.useCompression) return compressed;
            
            return {
                temp1: compressed.t1,
                temp2: compressed.t2,
                status_temp1: compressed.s1,
                status_temp2: compressed.s2,
                ip: compressed.ip,
                timestamp: compressed.ts,
                datetime: compressed.dt
            };
        }

        // Function to format temperature value with 2 decimal places
        function formatTemperature(temp, status) {
            if (status === "SENSOR_ERROR" || temp === -127) {
                return "Error";
            }
            // Format temperature to 2 decimal places
            return `${parseFloat(temp).toFixed(2)}°C`;
        }

        // Function to get temperature CSS class based on temperature ranges
        function getTemperatureClass(temp, status) {
            if (status === "SENSOR_ERROR" || temp === -127) {
                return "error";
            }
            
            const temperature = parseFloat(temp);
            
            // Temperature classification:
            // Cold: < 2°C (blue)
            // Optimal: 2-8°C (green)
            // Hot: > 8°C (red)
            
            if (temperature < 2) {
                return "cold";
            } else if (temperature >= 2 && temperature <= 8) {
                return "optimal";
            } else {
                return "hot";
            }
        }

        // Helper function to get temperature class from value (for averages)
        function getTemperatureClassFromValue(value) {
            if (value === 'N/A') return 'N/A';
            
            const temperature = parseFloat(value);
            
            if (temperature < 2) {
                return "cold";
            } else if (temperature >= 2 && temperature <= 8) {
                return "optimal";
            } else {
                return "hot";
            }
        }

        // Function to update device card
        function updateDeviceCard(deviceId, data) {
            const cardElement = document.querySelector(`[data-device-id="${deviceId}"]`);
            if (!cardElement) {
                console.warn(`Card element not found for device: ${deviceId}`);
                return;
            }

            const isOnline = isDeviceOnline(data.timestamp);
            const isCriticallyOffline = isDeviceCriticallyOffline(data.timestamp);
            const offlineDuration = getOfflineDuration(data.timestamp);

            // Debug red card logic
            console.log(`Updating card for ${deviceId}:`);
            console.log(`  Online: ${isOnline}`);
            console.log(`  Critical Offline: ${isCriticallyOffline}`);
            console.log(`  Offline Duration: ${offlineDuration} minutes`);

            // Update card styling based on critical offline status
            if (isCriticallyOffline && !isOnline) {
                console.log(`  -> Adding RED CARD styling to ${deviceId}`);
                cardElement.classList.add('offline-critical');
            } else {
                console.log(`  -> Removing RED CARD styling from ${deviceId}`);
                cardElement.classList.remove('offline-critical');
            }

            // Update status badge
            const statusBadge = cardElement.querySelector('.status-badge');
            if (statusBadge) {
                if (isOnline) {
                    statusBadge.textContent = 'ออนไลน์';
                    statusBadge.className = 'status-badge status-online';
                } else if (isCriticallyOffline) {
                    statusBadge.textContent = 'ออฟไลน์ (Critical)';
                    statusBadge.className = 'status-badge status-offline';
                    statusBadge.style.backgroundColor = '#c0392b';
                } else {
                    statusBadge.textContent = 'ออฟไลน์';
                    statusBadge.className = 'status-badge status-offline';
                    statusBadge.style.backgroundColor = '#e74c3c';
                }
            }

            // Update offline duration display
            const offlineDurationElement = cardElement.querySelector('.offline-duration');
            if (offlineDurationElement) {
                if (!isOnline && offlineDuration !== null) {
                    const durationText = cardElement.querySelector('.duration-text');
                    if (durationText) {
                        if (offlineDuration < 60) {
                            durationText.textContent = `Offline for: ${offlineDuration}m`;
                        } else {
                            const hours = Math.floor(offlineDuration / 60);
                            const minutes = offlineDuration % 60;
                            durationText.textContent = `Offline for: ${hours}h ${minutes}m`;
                        }
                    }
                    offlineDurationElement.style.display = 'block';
                    
                    // Change color based on duration
                    if (isCriticallyOffline) {
                        offlineDurationElement.className = 'offline-duration';
                        offlineDurationElement.innerHTML = `
                            <small class="text-light">
                                <i class="fas fa-exclamation-triangle me-1"></i>
                                <span class="duration-text">Offline for: ${offlineDuration < 60 ? offlineDuration + 'm' : Math.floor(offlineDuration / 60) + 'h ' + (offlineDuration % 60) + 'm'}</span>
                            </small>
                        `;
                    } else {
                        offlineDurationElement.innerHTML = `
                            <small class="text-warning">
                                <i class="fas fa-clock me-1"></i>
                                <span class="duration-text">Offline for: ${offlineDuration < 60 ? offlineDuration + 'm' : Math.floor(offlineDuration / 60) + 'h ' + (offlineDuration % 60) + 'm'}</span>
                            </small>
                        `;
                    }
                } else {
                    offlineDurationElement.style.display = 'none';
                }
            }

            // Update device zone
            const deviceType = cardElement.querySelector('.device-type');
            if (deviceType) {
                deviceType.textContent = data.zone || deviceId.split('-')[0];
            }

            // Update temperature 1
            const temp1Element = cardElement.querySelector('.temp1-value');
            if (temp1Element) {
                temp1Element.textContent = formatTemperature(data.temp1, data.status_temp1);
                temp1Element.className = `temp-value ${getTemperatureClass(data.temp1, data.status_temp1)}`;
            }

            // Update temperature 2
            const temp2Element = cardElement.querySelector('.temp2-value');
            if (temp2Element) {
                temp2Element.textContent = formatTemperature(data.temp2, data.status_temp2);
                temp2Element.className = `temp-value ${getTemperatureClass(data.temp2, data.status_temp2)}`;
            }

            // Update IP address
            const ipElement = cardElement.querySelector('.ip-address');
            if (ipElement) {
                ipElement.innerHTML = `<i class="fas fa-network-wired me-2"></i>IP Address: ${data.ip || '-'}`;
            }

            // Update last update time
            const lastUpdateElement = cardElement.querySelector('.last-update');
            if (lastUpdateElement) {
                lastUpdateElement.textContent = `อัปเดตล่าสุด: ${data.datetime || '-'}`;
            }

            // Log final card state
            console.log(`  Final card state: ${cardElement.classList.contains('offline-critical') ? 'RED CARD' : 'NORMAL CARD'}`);
        }

        // Function to update statistics
        function updateStatistics() {
            document.querySelector('.total-devices .stat-number').textContent = deviceList.length;
            document.querySelector('.online-devices .stat-number').textContent = onlineCount;
            document.querySelector('.offline-devices .stat-number').textContent = offlineCount;
        }

        // Function to recalculate and validate device counters
        function validateDeviceCounters() {
            let actualOnline = 0;
            let actualOffline = 0;
            let criticalOffline = 0;
            
            Object.values(deviceData).forEach(data => {
                if (data && data.timestamp) {
                    if (isDeviceOnline(data.timestamp)) {
                        actualOnline++;
                    } else {
                        actualOffline++;
                        if (isDeviceCriticallyOffline(data.timestamp)) {
                            criticalOffline++;
                        }
                    }
                }
            });
            
            // Check for devices without data
            const devicesWithoutData = deviceList.filter(deviceId => !deviceData[deviceId]);
            actualOffline += devicesWithoutData.length;
            criticalOffline += devicesWithoutData.length; // Assume devices without data are critically offline
            
            // Validate and correct if needed
            if (onlineCount !== actualOnline || offlineCount !== actualOffline) {
                console.warn(`Counter mismatch detected!`);
                console.warn(`Expected: Online=${onlineCount}, Offline=${offlineCount}`);
                console.warn(`Actual: Online=${actualOnline}, Offline=${actualOffline}`);
                console.warn(`Critical Offline: ${criticalOffline}`);
                console.warn(`Correcting counters...`);
                
                onlineCount = actualOnline;
                offlineCount = actualOffline;
                updateStatistics();
            }
            
            // Validate total count
            const totalCount = onlineCount + offlineCount;
            if (totalCount !== deviceList.length) {
                console.warn(`Total count mismatch: ${totalCount} vs ${deviceList.length}`);
                console.warn(`Devices without data:`, devicesWithoutData);
            }
            
            // Log critical offline devices
            if (criticalOffline > 0) {
                console.warn(`⚠️  ${criticalOffline} devices are critically offline (>30 minutes)`);
            }
            
            return {
                online: onlineCount,
                offline: offlineCount,
                criticalOffline: criticalOffline,
                total: deviceList.length,
                actualOnline,
                actualOffline,
                isValid: onlineCount === actualOnline && offlineCount === actualOffline
            };
        }

        // Function to reset and recalculate all counters
        function resetDeviceCounters() {
            console.log('Resetting device counters...');
            onlineCount = 0;
            offlineCount = 0;
            
            deviceList.forEach(deviceId => {
                const data = deviceData[deviceId];
                if (data && data.timestamp) {
                    if (isDeviceOnline(data.timestamp)) {
                        onlineCount++;
                    } else {
                        offlineCount++;
                    }
                } else {
                    offlineCount++;
                }
            });
            
            updateStatistics();
            console.log(`Counters reset - Online: ${onlineCount}, Offline: ${offlineCount}`);
            
            return validateDeviceCounters();
        }

        // Function to check red card status for offline devices
        function checkRedCardStatus() {
            console.log('=== RED CARD STATUS ANALYSIS ===');
            console.log('Analyzing offline device red card display...');
            console.log('');
            
            const currentTime = Math.floor(Date.now() / 1000);
            const criticalOfflineThreshold = 30 * 60; // 30 minutes in seconds
            
            console.log(`Current time: ${currentTime} (${new Date().toLocaleString()})`);
            console.log(`Online threshold: ${DATA_OPTIMIZATION.onlineThreshold} seconds (${Math.floor(DATA_OPTIMIZATION.onlineThreshold / 60)} minutes)`);
            console.log(`Critical offline threshold: ${criticalOfflineThreshold} seconds (${Math.floor(criticalOfflineThreshold / 60)} minutes)`);
            console.log('');
            
            let redCardDevices = [];
            let normalOfflineDevices = [];
            let onlineDevices = [];
            
            deviceList.forEach(deviceId => {
                const data = deviceData[deviceId];
                const cardElement = document.querySelector(`[data-device-id="${deviceId}"]`);
                
                if (data && data.timestamp) {
                    const deviceTime = parseInt(data.timestamp);
                    const timeDifference = currentTime - deviceTime;
                    const isOnline = timeDifference < DATA_OPTIMIZATION.onlineThreshold;
                    const isCriticallyOffline = timeDifference > criticalOfflineThreshold;
                    
                    const deviceStatus = {
                        deviceId: deviceId,
                        timestamp: deviceTime,
                        lastUpdate: data.datetime || 'N/A',
                        timeDifference: timeDifference,
                        timeDifferenceMinutes: Math.floor(timeDifference / 60),
                        isOnline: isOnline,
                        isCriticallyOffline: isCriticallyOffline,
                        hasRedCard: cardElement ? cardElement.classList.contains('offline-critical') : false,
                        cardExists: !!cardElement
                    };
                    
                    if (isOnline) {
                        onlineDevices.push(deviceStatus);
                    } else if (isCriticallyOffline) {
                        redCardDevices.push(deviceStatus);
                    } else {
                        normalOfflineDevices.push(deviceStatus);
                    }
                } else {
                    // Device with no data should be considered critically offline
                    const deviceStatus = {
                        deviceId: deviceId,
                        timestamp: null,
                        lastUpdate: 'Never',
                        timeDifference: null,
                        timeDifferenceMinutes: null,
                        isOnline: false,
                        isCriticallyOffline: true,
                        hasRedCard: cardElement ? cardElement.classList.contains('offline-critical') : false,
                        cardExists: !!cardElement
                    };
                    redCardDevices.push(deviceStatus);
                }
            });
            
            console.log(`📊 SUMMARY:`);
            console.log(`  Online devices: ${onlineDevices.length}`);
            console.log(`  Normal offline devices: ${normalOfflineDevices.length}`);
            console.log(`  Critical offline devices (RED CARD): ${redCardDevices.length}`);
            console.log('');
            
            // Analyze red card devices
            if (redCardDevices.length > 0) {
                console.log('🔴 RED CARD DEVICES (Critical Offline > 30 minutes):');
                redCardDevices.forEach((device, index) => {
                    console.log(`  ${index + 1}. ${device.deviceId}`);
                    console.log(`     Last Update: ${device.lastUpdate}`);
                    if (device.timeDifferenceMinutes !== null) {
                        console.log(`     Offline Duration: ${device.timeDifferenceMinutes} minutes`);
                    } else {
                        console.log(`     Offline Duration: No data received`);
                    }
                    console.log(`     Card has red styling: ${device.hasRedCard ? '✅' : '❌'}`);
                    console.log(`     Card exists in DOM: ${device.cardExists ? '✅' : '❌'}`);
                    console.log('');
                });
            }
            
            // Analyze normal offline devices
            if (normalOfflineDevices.length > 0) {
                console.log('🟡 NORMAL OFFLINE DEVICES (5-30 minutes):');
                normalOfflineDevices.forEach((device, index) => {
                    console.log(`  ${index + 1}. ${device.deviceId}`);
                    console.log(`     Last Update: ${device.lastUpdate}`);
                    console.log(`     Offline Duration: ${device.timeDifferenceMinutes} minutes`);
                    console.log(`     Card has red styling: ${device.hasRedCard ? '❌ (Should NOT be red)' : '✅'}`);
                    console.log(`     Card exists in DOM: ${device.cardExists ? '✅' : '❌'}`);
                    console.log('');
                });
            }
            
            // Analyze online devices
            if (onlineDevices.length > 0) {
                console.log('🟢 ONLINE DEVICES (< 5 minutes):');
                onlineDevices.forEach((device, index) => {
                    console.log(`  ${index + 1}. ${device.deviceId}`);
                    console.log(`     Last Update: ${device.lastUpdate}`);
                    console.log(`     Last data: ${Math.floor(device.timeDifference / 60)} minutes ago`);
                    console.log(`     Card has red styling: ${device.hasRedCard ? '❌ (Should NOT be red)' : '✅'}`);
                    console.log(`     Card exists in DOM: ${device.cardExists ? '✅' : '❌'}`);
                    console.log('');
                });
            }
            
            // Check for styling inconsistencies
            const stylingIssues = [];
            
            // Red cards that shouldn't be red
            onlineDevices.concat(normalOfflineDevices).forEach(device => {
                if (device.hasRedCard) {
                    stylingIssues.push(`${device.deviceId}: Has red styling but should NOT (${device.isOnline ? 'online' : 'normal offline'})`);
                }
            });
            
            // Devices that should be red but aren't
            redCardDevices.forEach(device => {
                if (!device.hasRedCard && device.cardExists) {
                    stylingIssues.push(`${device.deviceId}: Should have red styling but doesn't (critical offline)`);
                }
            });
            
            if (stylingIssues.length > 0) {
                console.log('⚠️  STYLING ISSUES DETECTED:');
                stylingIssues.forEach(issue => {
                    console.log(`  - ${issue}`);
                });
            } else {
                console.log('✅ All card stylings are correct!');
            }
            
            console.log('=== END RED CARD STATUS ANALYSIS ===');
            
            return {
                onlineDevices,
                normalOfflineDevices,
                redCardDevices,
                stylingIssues,
                summary: {
                    online: onlineDevices.length,
                    normalOffline: normalOfflineDevices.length,
                    criticalOffline: redCardDevices.length,
                    total: deviceList.length
                }
            };
        }

        // Function to fix red card styling issues
        function fixRedCardStyling() {
            console.log('=== FIXING RED CARD STYLING ===');
            
            const currentTime = Math.floor(Date.now() / 1000);
            const criticalOfflineThreshold = 30 * 60; // 30 minutes in seconds
            let fixedCount = 0;
            
            deviceList.forEach(deviceId => {
                const data = deviceData[deviceId];
                const cardElement = document.querySelector(`[data-device-id="${deviceId}"]`);
                
                if (!cardElement) {
                    console.log(`❌ Card element not found for ${deviceId}`);
                    return;
                }
                
                let shouldBeRed = false;
                
                if (data && data.timestamp) {
                    const deviceTime = parseInt(data.timestamp);
                    const timeDifference = currentTime - deviceTime;
                    const isOnline = timeDifference < DATA_OPTIMIZATION.onlineThreshold;
                    const isCriticallyOffline = timeDifference > criticalOfflineThreshold;
                    
                    shouldBeRed = !isOnline && isCriticallyOffline;
                } else {
                    // No data = critically offline
                    shouldBeRed = true;
                }
                
                const hasRedCard = cardElement.classList.contains('offline-critical');
                
                if (shouldBeRed && !hasRedCard) {
                    console.log(`🔧 Adding red styling to ${deviceId} (critical offline)`);
                    cardElement.classList.add('offline-critical');
                    fixedCount++;
                } else if (!shouldBeRed && hasRedCard) {
                    console.log(`🔧 Removing red styling from ${deviceId} (not critical offline)`);
                    cardElement.classList.remove('offline-critical');
                    fixedCount++;
                }
            });
            
            console.log(`✅ Fixed ${fixedCount} styling issues`);
            console.log('=== END FIXING RED CARD STYLING ===');
            
            return fixedCount;
        }

        // Function to get a quick summary of red card status
        function getRedCardSummary() {
            const currentTime = Math.floor(Date.now() / 1000);
            const criticalOfflineThreshold = 30 * 60; // 30 minutes in seconds
            
            let summary = {
                total: deviceList.length,
                online: 0,
                normalOffline: 0,
                criticalOffline: 0,
                redCardCount: 0,
                stylingIssues: 0,
                devicesWithRedCards: [],
                devicesWithStylingIssues: []
            };
            
            deviceList.forEach(deviceId => {
                const data = deviceData[deviceId];
                const cardElement = document.querySelector(`[data-device-id="${deviceId}"]`);
                const hasRedCard = cardElement ? cardElement.classList.contains('offline-critical') : false;
                
                if (hasRedCard) {
                    summary.redCardCount++;
                    summary.devicesWithRedCards.push(deviceId);
                }
                
                if (data && data.timestamp) {
                    const deviceTime = parseInt(data.timestamp);
                    const timeDifference = currentTime - deviceTime;
                    const isOnline = timeDifference < DATA_OPTIMIZATION.onlineThreshold;
                    const isCriticallyOffline = timeDifference > criticalOfflineThreshold;
                    
                    if (isOnline) {
                        summary.online++;
                        if (hasRedCard) {
                            summary.stylingIssues++;
                            summary.devicesWithStylingIssues.push(`${deviceId} (online but red)`);
                        }
                    } else if (isCriticallyOffline) {
                        summary.criticalOffline++;
                        if (!hasRedCard) {
                            summary.stylingIssues++;
                            summary.devicesWithStylingIssues.push(`${deviceId} (critical offline but not red)`);
                        }
                    } else {
                        summary.normalOffline++;
                        if (hasRedCard) {
                            summary.stylingIssues++;
                            summary.devicesWithStylingIssues.push(`${deviceId} (normal offline but red)`);
                        }
                    }
                } else {
                    // No data = critically offline
                    summary.criticalOffline++;
                    if (!hasRedCard) {
                        summary.stylingIssues++;
                        summary.devicesWithStylingIssues.push(`${deviceId} (no data but not red)`);
                    }
                }
            });
            
            return summary;
        }

        // Add keyboard shortcut for red card status check
        document.addEventListener('keydown', function(event) {
            // Ctrl+R for red card status check
            if (event.ctrlKey && event.key === 'r') {
                event.preventDefault();
                checkRedCardStatus();
            }
            // Ctrl+F for fix red card styling
            if (event.ctrlKey && event.key === 'f') {
                event.preventDefault();
                fixRedCardStyling();
            }
        });

        // Auto-check red card status every 2 minutes
        setInterval(() => {
            const summary = getRedCardSummary();
            if (summary.stylingIssues > 0) {
                console.warn(`⚠️  ${summary.stylingIssues} red card styling issues detected. Use Ctrl+R to analyze or Ctrl+F to fix.`);
            }
        }, 120000); // 2 minutes

        // Function to query and display last temperature readings from all devices
        function queryLastTemperatures() {
            const queryTime = new Date();
            const queryTimeString = queryTime.toLocaleString('th-TH');
            
            console.log('=== LAST TEMPERATURE MONITORING REPORT ===');
            console.log('Query Time:', queryTimeString);
            console.log('----------------------------------------');
            
            // Update UI with last query time
            const lastQueryElement = document.getElementById('last-query-time');
            if (lastQueryElement) {
                lastQueryElement.textContent = `Last: ${queryTime.toLocaleTimeString('th-TH')}`;
            }
            
            if (deviceList.length === 0) {
                console.log('No devices found in database');
                return;
            }

            const temperatureReport = [];
            
            deviceList.forEach(deviceId => {
                const data = deviceData[deviceId];
                if (data) {
                    const isOnline = isDeviceOnline(data.timestamp);
                    const isCriticallyOffline = isDeviceCriticallyOffline(data.timestamp);
                    const offlineDuration = getOfflineDuration(data.timestamp);
                    const temp1Status = data.status_temp1 === "SENSOR_ERROR" ? "ERROR" : "OK";
                    const temp2Status = data.status_temp2 === "SENSOR_ERROR" ? "ERROR" : "OK";
                    
                    const deviceReport = {
                        deviceId: deviceId,
                        zone: data.zone || deviceId.split('-')[0],
                        status: isOnline ? 'ONLINE' : (isCriticallyOffline ? 'CRITICAL_OFFLINE' : 'OFFLINE'),
                        temp1: data.temp1 === -127 ? 'ERROR' : `${parseFloat(data.temp1).toFixed(2)}°C`,
                        temp1Status: temp1Status,
                        temp1Class: getTemperatureClass(data.temp1, data.status_temp1),
                        temp2: data.temp2 === -127 ? 'ERROR' : `${parseFloat(data.temp2).toFixed(2)}°C`,
                        temp2Status: temp2Status,
                        temp2Class: getTemperatureClass(data.temp2, data.status_temp2),
                        ip: data.ip || 'N/A',
                        lastUpdate: data.datetime || 'N/A',
                        timestamp: data.timestamp,
                        offlineDuration: offlineDuration
                    };
                    
                    temperatureReport.push(deviceReport);
                    
                    console.log(`Device: ${deviceId}`);
                    console.log(`  Zone: ${deviceReport.zone}`);
                    console.log(`  Status: ${deviceReport.status}`);
                    if (!isOnline && offlineDuration !== null) {
                        console.log(`  Offline Duration: ${offlineDuration} minutes`);
                    }
                    console.log(`  Temperature 1: ${deviceReport.temp1} (${temp1Status}) [${deviceReport.temp1Class}]`);
                    console.log(`  Temperature 2: ${deviceReport.temp2} (${temp2Status}) [${deviceReport.temp2Class}]`);
                    console.log(`  IP Address: ${deviceReport.ip}`);
                    console.log(`  Last Update: ${deviceReport.lastUpdate}`);
                    console.log('  ---');
                } else {
                    console.log(`Device: ${deviceId} - NO DATA RECEIVED`);
                    temperatureReport.push({
                        deviceId: deviceId,
                        zone: deviceId.split('-')[0],
                        status: 'NO_DATA',
                        temp1: 'N/A',
                        temp1Status: 'N/A',
                        temp2: 'N/A',
                        temp2Status: 'N/A',
                        ip: 'N/A',
                        lastUpdate: 'N/A',
                        timestamp: null,
                        offlineDuration: null
                    });
                }
            });
            
            console.log('----------------------------------------');
            console.log(`Total Devices: ${deviceList.length}`);
            console.log(`Online Devices: ${onlineCount}`);
            console.log(`Offline Devices: ${offlineCount}`);
            console.log('=== END OF TEMPERATURE REPORT ===');
            
            // Store report data for PDF export
            lastReportData = temperatureReport.map(device => ({
                deviceId: device.deviceId,
                zone: device.zone,
                status: device.status.toLowerCase(),
                temp1: device.temp1 !== 'ERROR' ? parseFloat(device.temp1) : null,
                temp1Status: device.temp1Status,
                temp1Class: device.temp1Class || 'unknown',
                temp2: device.temp2 !== 'ERROR' ? parseFloat(device.temp2) : null,
                temp2Status: device.temp2Status,
                temp2Class: device.temp2Class || 'unknown',
                lastUpdate: device.lastUpdate,
                criticalOffline: device.status === 'CRITICAL_OFFLINE',
                ip: device.ip || 'N/A'
            }));
            lastReportGenerated = queryTimeString;
            
            return temperatureReport;
        }

        // Function to get temperature summary for specific zones
        function getTemperatureSummaryByZone() {
            const zoneSummary = {};
            
            deviceList.forEach(deviceId => {
                const data = deviceData[deviceId];
                const zone = data?.zone || deviceId.split('-')[0];
                
                if (!zoneSummary[zone]) {
                    zoneSummary[zone] = {
                        devices: [],
                        onlineCount: 0,
                        offlineCount: 0,
                        avgTemp1: 0,
                        avgTemp2: 0,
                        validTemp1Count: 0,
                        validTemp2Count: 0
                    };
                }
                
                zoneSummary[zone].devices.push(deviceId);
                
                if (data) {
                    const isOnline = isDeviceOnline(data.timestamp);
                    if (isOnline) {
                        zoneSummary[zone].onlineCount++;
                    } else {
                        zoneSummary[zone].offlineCount++;
                    }
                    
                    // Calculate average temperatures (excluding errors) with 2 decimal places
                    if (data.temp1 !== -127 && data.status_temp1 !== "SENSOR_ERROR") {
                        zoneSummary[zone].avgTemp1 += parseFloat(data.temp1);
                        zoneSummary[zone].validTemp1Count++;
                    }
                    
                    if (data.temp2 !== -127 && data.status_temp2 !== "SENSOR_ERROR") {
                        zoneSummary[zone].avgTemp2 += parseFloat(data.temp2);
                        zoneSummary[zone].validTemp2Count++;
                    }
                } else {
                    zoneSummary[zone].offlineCount++;
                }
            });
            
            // Calculate averages with 2 decimal places
            Object.keys(zoneSummary).forEach(zone => {
                if (zoneSummary[zone].validTemp1Count > 0) {
                    zoneSummary[zone].avgTemp1 = (zoneSummary[zone].avgTemp1 / zoneSummary[zone].validTemp1Count).toFixed(2);
                } else {
                    zoneSummary[zone].avgTemp1 = 'N/A';
                }
                
                if (zoneSummary[zone].validTemp2Count > 0) {
                    zoneSummary[zone].avgTemp2 = (zoneSummary[zone].avgTemp2 / zoneSummary[zone].validTemp2Count).toFixed(2);
                } else {
                    zoneSummary[zone].avgTemp2 = 'N/A';
                }
            });
            
            console.log('=== TEMPERATURE SUMMARY BY ZONE ===');
            Object.entries(zoneSummary).forEach(([zone, summary]) => {
                console.log(`Zone: ${zone}`);
                console.log(`  Devices: ${summary.devices.join(', ')}`);
                console.log(`  Online: ${summary.onlineCount}, Offline: ${summary.offlineCount}`);
                console.log(`  Average Temp1: ${summary.avgTemp1}°C [${getTemperatureClassFromValue(summary.avgTemp1)}]`);
                console.log(`  Average Temp2: ${summary.avgTemp2}°C [${getTemperatureClassFromValue(summary.avgTemp2)}]`);
                console.log('  ---');
            });
            
            return zoneSummary;
        }

        // Function to get temperature classification report
        function getTemperatureClassificationReport() {
            const classification = {
                temp1: {
                    cold: 0, optimal: 0, hot: 0, error: 0,
                    devices: { cold: [], optimal: [], hot: [], error: [] }
                },
                temp2: {
                    cold: 0, optimal: 0, hot: 0, error: 0,
                    devices: { cold: [], optimal: [], hot: [], error: [] }
                },
                // Legacy fields for backward compatibility
                cold: { devices: [], count: 0, range: '< 2°C' },
                optimal: { devices: [], count: 0, range: '2-8°C' },
                hot: { devices: [], count: 0, range: '> 8°C' },
                error: { devices: [], count: 0, range: 'Error' }
            };
            
            deviceList.forEach(deviceId => {
                const data = deviceData[deviceId];
                if (data) {
                    // Check temp1
                    const temp1Class = getTemperatureClass(data.temp1, data.status_temp1);
                    if (temp1Class === 'cold') {
                        classification.temp1.cold++;
                        classification.temp1.devices.cold.push(`${deviceId} (${parseFloat(data.temp1).toFixed(2)}°C)`);
                        // Legacy
                        classification.cold.devices.push(`${deviceId} (T1: ${parseFloat(data.temp1).toFixed(2)}°C)`);
                        classification.cold.count++;
                    } else if (temp1Class === 'optimal') {
                        classification.temp1.optimal++;
                        classification.temp1.devices.optimal.push(`${deviceId} (${parseFloat(data.temp1).toFixed(2)}°C)`);
                        // Legacy
                        classification.optimal.devices.push(`${deviceId} (T1: ${parseFloat(data.temp1).toFixed(2)}°C)`);
                        classification.optimal.count++;
                    } else if (temp1Class === 'hot') {
                        classification.temp1.hot++;
                        classification.temp1.devices.hot.push(`${deviceId} (${parseFloat(data.temp1).toFixed(2)}°C)`);
                        // Legacy
                        classification.hot.devices.push(`${deviceId} (T1: ${parseFloat(data.temp1).toFixed(2)}°C)`);
                        classification.hot.count++;
                    } else {
                        classification.temp1.error++;
                        classification.temp1.devices.error.push(`${deviceId} (Error)`);
                        // Legacy
                        classification.error.devices.push(`${deviceId} (T1: Error)`);
                        classification.error.count++;
                    }
                    
                    // Check temp2
                    const temp2Class = getTemperatureClass(data.temp2, data.status_temp2);
                    if (temp2Class === 'cold') {
                        classification.temp2.cold++;
                        classification.temp2.devices.cold.push(`${deviceId} (${parseFloat(data.temp2).toFixed(2)}°C)`);
                        // Legacy
                        classification.cold.devices.push(`${deviceId} (T2: ${parseFloat(data.temp2).toFixed(2)}°C)`);
                        classification.cold.count++;
                    } else if (temp2Class === 'optimal') {
                        classification.temp2.optimal++;
                        classification.temp2.devices.optimal.push(`${deviceId} (${parseFloat(data.temp2).toFixed(2)}°C)`);
                        // Legacy
                        classification.optimal.devices.push(`${deviceId} (T2: ${parseFloat(data.temp2).toFixed(2)}°C)`);
                        classification.optimal.count++;
                    } else if (temp2Class === 'hot') {
                        classification.temp2.hot++;
                        classification.temp2.devices.hot.push(`${deviceId} (${parseFloat(data.temp2).toFixed(2)}°C)`);
                        // Legacy
                        classification.hot.devices.push(`${deviceId} (T2: ${parseFloat(data.temp2).toFixed(2)}°C)`);
                        classification.hot.count++;
                    } else {
                        classification.temp2.error++;
                        classification.temp2.devices.error.push(`${deviceId} (Error)`);
                        // Legacy
                        classification.error.devices.push(`${deviceId} (T2: Error)`);
                        classification.error.count++;
                    }
                }
            });
            
            console.log('=== ENHANCED TEMPERATURE CLASSIFICATION REPORT ===');
            console.log('TEMPERATURE 1 READINGS:');
            console.log(`🟦 Cold (<2°C): ${classification.temp1.cold} readings`);
            if (classification.temp1.cold > 0) {
                classification.temp1.devices.cold.forEach(device => console.log(`  ${device}`));
            }
            console.log(`🟢 Optimal (2-8°C): ${classification.temp1.optimal} readings`);
            if (classification.temp1.optimal > 0) {
                classification.temp1.devices.optimal.forEach(device => console.log(`  ${device}`));
            }
            console.log(`� Hot (>8°C): ${classification.temp1.hot} readings`);
            if (classification.temp1.hot > 0) {
                classification.temp1.devices.hot.forEach(device => console.log(`  ${device}`));
            }
            console.log(`❌ Errors: ${classification.temp1.error} readings`);
            if (classification.temp1.error > 0) {
                classification.temp1.devices.error.forEach(device => console.log(`  ${device}`));
            }
            
            console.log('\nTEMPERATURE 2 READINGS:');
            console.log(`� Cold (<2°C): ${classification.temp2.cold} readings`);
            if (classification.temp2.cold > 0) {
                classification.temp2.devices.cold.forEach(device => console.log(`  ${device}`));
            }
            console.log(`🟢 Optimal (2-8°C): ${classification.temp2.optimal} readings`);
            if (classification.temp2.optimal > 0) {
                classification.temp2.devices.optimal.forEach(device => console.log(`  ${device}`));
            }
            console.log(`🔴 Hot (>8°C): ${classification.temp2.hot} readings`);
            if (classification.temp2.hot > 0) {
                classification.temp2.devices.hot.forEach(device => console.log(`  ${device}`));
            }
            console.log(`❌ Errors: ${classification.temp2.error} readings`);
            if (classification.temp2.error > 0) {
                classification.temp2.devices.error.forEach(device => console.log(`  ${device}`));
            }
            
            console.log('==========================================');
            
            return classification;
        }
        // Function to get critically offline devices (>30 minutes)
        function getCriticalOfflineDevices() {
            const criticalDevices = [];
            
            deviceList.forEach(deviceId => {
                const data = deviceData[deviceId];
                if (data && data.timestamp) {
                    if (isDeviceCriticallyOffline(data.timestamp) && !isDeviceOnline(data.timestamp)) {
                        const offlineDuration = getOfflineDuration(data.timestamp);
                        criticalDevices.push({
                            deviceId: deviceId,
                            zone: data.zone || deviceId.split('-')[0],
                            offlineDuration: offlineDuration,
                            offlineDurationText: offlineDuration < 60 ? `${offlineDuration}m` : `${Math.floor(offlineDuration / 60)}h ${offlineDuration % 60}m`,
                            lastUpdate: data.datetime || 'N/A',
                            timestamp: data.timestamp
                        });
                    }
                } else {
                    // Device without data is considered critically offline
                    criticalDevices.push({
                        deviceId: deviceId,
                        zone: deviceId.split('-')[0],
                        offlineDuration: null,
                        offlineDurationText: 'No data',
                        lastUpdate: 'Never',
                        timestamp: null
                    });
                }
            });
            
            // Sort by offline duration (longest first)
            criticalDevices.sort((a, b) => {
                if (a.offlineDuration === null) return 1;
                if (b.offlineDuration === null) return -1;
                return b.offlineDuration - a.offlineDuration;
            });
            
            console.log('=== CRITICAL OFFLINE DEVICES (>30 minutes) ===');
            if (criticalDevices.length === 0) {
                console.log('✅ No critically offline devices found');
            } else {
                console.log(`⚠️  Found ${criticalDevices.length} critically offline devices:`);
                criticalDevices.forEach(device => {
                    console.log(`  ${device.deviceId} (${device.zone}) - Offline: ${device.offlineDurationText}`);
                });
            }
            console.log('===============================================');
            
            return criticalDevices;
        }

        // Enhanced cache cleanup to prevent memory bloat
        function cleanupCache() {
            const now = Date.now();
            const keysToDelete = [];
            
            // Check cache size limit
            if (dataCache.size > DATA_OPTIMIZATION.maxCacheSize) {
                // Sort by timestamp and remove oldest entries
                const sortedEntries = Array.from(dataCache.entries())
                    .sort((a, b) => a[1].timestamp - b[1].timestamp);
                
                const excessEntries = sortedEntries.slice(0, dataCache.size - DATA_OPTIMIZATION.maxCacheSize);
                excessEntries.forEach(([key]) => keysToDelete.push(key));
            }
            
            // Remove expired entries
            dataCache.forEach((value, key) => {
                const age = now - value.timestamp;
                if (age > DATA_OPTIMIZATION.cacheTimeout * 3) { // 3x timeout for cleanup
                    keysToDelete.push(key);
                }
            });
            
            // Perform cleanup
            keysToDelete.forEach(key => {
                dataCache.delete(key);
            });
            
            if (keysToDelete.length > 0) {
                console.log(`Cleaned up ${keysToDelete.length} cache entries (cache size: ${dataCache.size})`);
            }
        }

        // Function to cleanup device listeners
        function cleanupDeviceListeners() {
            deviceListeners.forEach((unsubscribe, deviceId) => {
                if (unsubscribe && typeof unsubscribe === 'function') {
                    unsubscribe();
                    console.log(`Cleaned up listener for ${deviceId}`);
                }
            });
            deviceListeners.clear();
        }

        // Enhanced data usage statistics with latest data monitoring
        function getDataUsageStats() {
            const stats = {
                cacheSize: dataCache.size,
                maxCacheSize: DATA_OPTIMIZATION.maxCacheSize,
                activeListeners: deviceListeners.size,
                deviceDataSize: Object.keys(deviceData).length,
                optimizationSettings: DATA_OPTIMIZATION,
                cacheHitRate: calculateCacheHitRate(),
                averageDataAge: calculateAverageDataAge(),
                lastDataUpdate: getLastDataUpdate()
            };
            
            console.log('=== ENHANCED DATA USAGE STATISTICS ===');
            console.log('Cache entries:', stats.cacheSize, '/', stats.maxCacheSize);
            console.log('Active listeners:', stats.activeListeners);
            console.log('Device data entries:', stats.deviceDataSize);
            console.log('Cache hit rate:', stats.cacheHitRate);
            console.log('Average data age:', stats.averageDataAge);
            console.log('Last data update:', stats.lastDataUpdate);
            console.log('Latest data only mode:', DATA_OPTIMIZATION.useLatestDataOnly);
            console.log('Optimization settings:', stats.optimizationSettings);
            console.log('======================================');
            
            return stats;
        }

        // Calculate cache hit rate for monitoring
        function calculateCacheHitRate() {
            // This is a simplified calculation
            const cacheEntries = dataCache.size;
            const totalDevices = deviceList.length;
            
            if (totalDevices === 0) return '0%';
            
            const hitRate = Math.round((cacheEntries / (totalDevices * 2)) * 100); // *2 for device + monitoring cache
            return `${Math.min(hitRate, 100)}%`;
        }

        // Calculate average age of cached data
        function calculateAverageDataAge() {
            if (dataCache.size === 0) return '0s';
            
            const now = Date.now();
            let totalAge = 0;
            
            dataCache.forEach(value => {
                totalAge += (now - value.timestamp);
            });
            
            const averageAge = Math.round((totalAge / dataCache.size) / 1000);
            return `${averageAge}s`;
        }

        // Get timestamp of last data update
        function getLastDataUpdate() {
            let lastUpdate = 0;
            
            Object.values(deviceData).forEach(data => {
                if (data.timestamp && parseInt(data.timestamp) > lastUpdate) {
                    lastUpdate = parseInt(data.timestamp);
                }
            });
            
            if (lastUpdate === 0) return 'Never';
            
            const now = Math.floor(Date.now() / 1000);
            const ageInSeconds = now - lastUpdate;
            
            if (ageInSeconds < 60) {
                return `${ageInSeconds}s ago`;
            } else if (ageInSeconds < 3600) {
                return `${Math.floor(ageInSeconds / 60)}m ago`;
            } else {
                return `${Math.floor(ageInSeconds / 3600)}h ago`;
            }
        }

        // Handle page unload to cleanup connections
        window.addEventListener('beforeunload', () => {
            console.log('Cleaning up Firebase connections...');
            cleanupDeviceListeners();
        });

        // Optimized function to fetch devices with caching
        function fetchAllDevices() {
            return new Promise((resolve, reject) => {
                const cacheKey = 'deviceList';
                
                // Check cache first
                if (isDataFresh(cacheKey)) {
                    console.log('Using cached device list');
                    resolve(dataCache.get(cacheKey).data);
                    return;
                }
                
                console.log('Fetching devices from Firebase...');
                const devicesRef = ref(database, 'devices');
                
                onValue(devicesRef, (snapshot) => {
                    const data = snapshot.val();
                    console.log('Raw Firebase data:', data);
                    
                    if (data) {
                        const devices = Object.keys(data);
                        console.log('Device keys found:', devices);
                        
                        // Cache the result
                        dataCache.set(cacheKey, {
                            data: devices,
                            timestamp: Date.now()
                        });
                        
                        console.log('Successfully found devices in database:', devices);
                        resolve(devices);
                    } else {
                        console.error('No devices found in Firebase database');
                        console.log('Database path checked: devices/');
                        resolve([]);
                    }
                }, (error) => {
                    console.error('Firebase error fetching devices:', error);
                    console.error('Error code:', error.code);
                    console.error('Error message:', error.message);
                    reject(error);
                }, { once: true });
            });
        }

        // Optimized function to clean old log entries (using limited query)
        function cleanOldLogEntries(deviceId) {
            const deviceLogRef = ref(database, `devices/${deviceId}/log`);
            
            // Use a query to get only recent entries for checking
            const recentQuery = query(
                deviceLogRef,
                orderByChild('timestamp'),
                limitToLast(DATA_OPTIMIZATION.maxLogEntries + 20) // Get slightly more than needed
            );
            
            onValue(recentQuery, (snapshot) => {
                const logData = snapshot.val();
                if (logData) {
                    const entries = Object.entries(logData);
                    
                    // Sort by timestamp (newest first)
                    entries.sort((a, b) => parseInt(b[1].timestamp) - parseInt(a[1].timestamp));
                    
                    // Check if we need to clean up old entries
                    if (entries.length > DATA_OPTIMIZATION.maxLogEntries) {
                        const entriesToDelete = entries.slice(DATA_OPTIMIZATION.maxLogEntries);
                        console.log(`Found ${entriesToDelete.length} old entries for ${deviceId} (cleanup needed)`);
                        
                        // Note: In a real implementation, you would delete these entries
                        // For now, we'll just log the cleanup action
                        // This requires Firebase Admin SDK or Cloud Functions
                    }
                    
                    // Check for very old entries (older than maxDataAge)
                    const now = Math.floor(Date.now() / 1000);
                    const oldEntries = entries.filter(([key, data]) => {
                        const age = now - parseInt(data.timestamp);
                        return age > DATA_OPTIMIZATION.maxDataAge;
                    });
                    
                    if (oldEntries.length > 0) {
                        console.log(`Found ${oldEntries.length} entries older than 24 hours for ${deviceId} (cleanup needed)`);
                    }
                }
            }, { once: true });
        }

        // Function to check for new devices periodically (optimized)
        function monitorDeviceChanges() {
            const devicesRef = ref(database, 'devices');
            
            // Use cache to reduce monitoring frequency
            const cacheKey = 'device_monitoring';
            
            onValue(devicesRef, async (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const currentDevices = Object.keys(data);
                    
                    // Check cache to avoid unnecessary processing
                    const cached = dataCache.get(cacheKey);
                    if (cached && JSON.stringify(cached.data) === JSON.stringify(currentDevices)) {
                        return; // No change, skip processing
                    }
                    
                    // Cache current device list
                    dataCache.set(cacheKey, {
                        data: currentDevices,
                        timestamp: Date.now()
                    });
                    
                    const newDevices = currentDevices.filter(device => !deviceList.includes(device));
                    const removedDevices = deviceList.filter(device => !currentDevices.includes(device));
                    
                    if (newDevices.length > 0 || removedDevices.length > 0) {
                        console.log('Device list changed. New devices:', newDevices, 'Removed devices:', removedDevices);
                        
                        // Update device list
                        deviceList = currentDevices;
                        
                        // Update total devices count
                        document.querySelector('.total-devices .stat-number').textContent = deviceList.length;
                        
                        // Re-render all cards
                        renderDeviceCards();
                        
                        // Start listening to new devices
                        newDevices.forEach(deviceId => {
                            listenToDevice(deviceId);
                        });
                        
                        // Clean up removed devices from deviceData and listeners
                        removedDevices.forEach(deviceId => {
                            if (deviceData[deviceId]) {
                                delete deviceData[deviceId];
                            }
                            // Clean up listener
                            if (deviceListeners.has(deviceId)) {
                                const unsubscribe = deviceListeners.get(deviceId);
                                if (unsubscribe) unsubscribe();
                                deviceListeners.delete(deviceId);
                            }
                        });
                        
                        // Recalculate statistics
                        onlineCount = 0;
                        offlineCount = 0;
                        Object.values(deviceData).forEach(data => {
                            if (isDeviceOnline(data.timestamp)) {
                                onlineCount++;
                            } else {
                                offlineCount++;
                            }
                        });
                        updateStatistics();
                    }
                }
            });
        }

        // Optimized function to listen to device data with minimal reads
        function listenToDevice(deviceId) {
            const cacheKey = `device_${deviceId}`;
            
            // Check if we already have a listener for this device
            if (deviceListeners.has(deviceId)) {
                console.log(`Listener already exists for ${deviceId}`);
                return;
            }
            
            // Use orderByChild and limitToLast to get only the latest entry
            const deviceLogRef = ref(database, `devices/${deviceId}/log`);
            
            // Create a query to get only the latest entries (reduced from 5 to 3)
            const latestQuery = query(
                deviceLogRef,
                orderByChild('timestamp'),
                limitToLast(3) // Reduced from 5 to 3 - Even more minimal data transfer
            );
            
            const unsubscribe = onValue(latestQuery, (snapshot) => {
                const logData = snapshot.val();
                console.log(`Firebase data received for ${deviceId}:`, logData);
                
                if (logData) {
                    // Find the latest entry by timestamp
                    let latestData = null;
                    let latestTimestamp = 0;

                    Object.values(logData).forEach(entry => {
                        if (entry.timestamp && parseInt(entry.timestamp) > latestTimestamp) {
                            latestTimestamp = parseInt(entry.timestamp);
                            latestData = entry;
                        }
                    });

                    if (latestData) {
                        console.log(`Latest data for ${deviceId}:`, latestData);
                        console.log(`Device ${deviceId} timestamp: ${latestData.timestamp} (${new Date(latestData.timestamp * 1000).toLocaleString()})`);
                        
                        // Check cache to avoid unnecessary updates
                        const cached = dataCache.get(cacheKey);
                        if (cached && cached.data.timestamp === latestData.timestamp) {
                            console.log(`Data unchanged for ${deviceId}, skipping update`);
                            return; // No change, skip update
                        }
                        
                        // Compress data for storage
                        const compressedData = compressDeviceData(latestData);
                        
                        // Update cache
                        dataCache.set(cacheKey, {
                            data: compressedData,
                            timestamp: Date.now()
                        });

                        const wasOnline = deviceData[deviceId] ? isDeviceOnline(deviceData[deviceId].timestamp) : false;
                        const isOnline = isDeviceOnline(latestData.timestamp);
                        
                        console.log(`Device ${deviceId} status change: ${wasOnline ? 'ONLINE' : 'OFFLINE'} -> ${isOnline ? 'ONLINE' : 'OFFLINE'}`);

                        // Update online/offline counts
                        if (wasOnline && !isOnline) {
                            onlineCount--;
                            offlineCount++;
                            console.log(`Device ${deviceId} went offline. Online: ${onlineCount}, Offline: ${offlineCount}`);
                        } else if (!wasOnline && isOnline) {
                            onlineCount++;
                            offlineCount--;
                            console.log(`Device ${deviceId} came online. Online: ${onlineCount}, Offline: ${offlineCount}`);
                        } else if (!deviceData[deviceId]) {
                            // First time loading this device
                            if (isOnline) {
                                onlineCount++;
                                console.log(`New device ${deviceId} is online. Online: ${onlineCount}`);
                            } else {
                                offlineCount++;
                                console.log(`New device ${deviceId} is offline. Offline: ${offlineCount}`);
                            }
                        }

                        // Store decompressed data for UI
                        deviceData[deviceId] = decompressDeviceData(compressedData);
                        updateDeviceCard(deviceId, deviceData[deviceId]);
                        updateStatistics();

                        console.log(`Updated ${deviceId} (optimized):`, deviceData[deviceId]);
                        
                        // Validate counters periodically (every 10th update)
                        if (Math.random() < 0.1) {
                            validateDeviceCounters();
                        }
                    }
                } else {
                    console.warn(`No log data found for ${deviceId}`);
                    if (deviceData[deviceId] && isDeviceOnline(deviceData[deviceId].timestamp)) {
                        onlineCount--;
                        offlineCount++;
                        updateStatistics();
                    }
                }
            }, (error) => {
                console.error(`Error listening to ${deviceId}/log:`, error);
                if (deviceData[deviceId] && isDeviceOnline(deviceData[deviceId].timestamp)) {
                    onlineCount--;
                    offlineCount++;
                    updateStatistics();
                }
            });
            
            // Store listener reference for cleanup
            deviceListeners.set(deviceId, unsubscribe);
        }

        // Initialize the application
        async function startApp() {
            console.log('Initializing Temperature Monitor Dashboard...');
            
            try {
                // Fetch all devices from database
                deviceList = await fetchAllDevices();
                
                if (deviceList.length === 0) {
                    console.warn('No devices found in database');
                    const container = document.getElementById('device-cards-container');
                    container.innerHTML = `
                        <div class="col-12 text-center">
                            <div class="alert alert-warning" role="alert">
                                <i class="fas fa-exclamation-triangle fa-2x mb-3"></i>
                                <h4>ไม่พบอุปกรณ์</h4>
                                <p class="mb-0">ไม่มีอุปกรณ์ในฐานข้อมูล กรุณาตรวจสอบการเชื่อมต่อ</p>
                            </div>
                        </div>
                    `;
                    return;
                }
                
                console.log('Monitoring devices:', deviceList);
                
                // Update total devices count
                document.querySelector('.total-devices .stat-number').textContent = deviceList.length;

                // Render device cards
                renderDeviceCards();

                // Start listening to devices in batches to reduce simultaneous connections
                const batchSize = DATA_OPTIMIZATION.batchSize;
                for (let i = 0; i < deviceList.length; i += batchSize) {
                    const batch = deviceList.slice(i, i + batchSize);
                    
                    // Add delay between batches to avoid overwhelming Firebase
                    setTimeout(() => {
                        console.log(`Starting batch ${Math.floor(i/batchSize) + 1}:`, batch);
                        batch.forEach(deviceId => {
                            listenToDevice(deviceId);
                        });
                    }, (i / batchSize) * 1000); // 1 second delay between batches
                }

                // Start monitoring for device changes (less frequent)
                setTimeout(() => {
                    monitorDeviceChanges();
                }, 5000); // Delay device monitoring

                // Start periodic temperature monitoring (reduced to every 2 minutes)
                setInterval(() => {
                    queryLastTemperatures();
                }, 120000); // Every 120 seconds (2 minutes) instead of 60

                // Start periodic cache cleanup (increased to every 10 minutes)
                setInterval(() => {
                    cleanupCache();
                }, DATA_OPTIMIZATION.cleanupInterval);

                // Start periodic log cleanup (check every 15 minutes instead of 10)
                setInterval(() => {
                    if (deviceList.length > 0) {
                        const randomDevice = deviceList[Math.floor(Math.random() * deviceList.length)];
                        cleanOldLogEntries(randomDevice);
                    }
                }, 900000); // 15 minutes instead of 10

                // Start periodic counter validation (every 2 minutes)
                setInterval(() => {
                    console.log('Running periodic counter validation...');
                    const validation = validateDeviceCounters();
                    if (!validation.isValid) {
                        console.warn('Counter validation failed, resetting...');
                        resetDeviceCounters();
                    }
                }, 120000); // 2 minutes

                // Initial counter validation after startup
                setTimeout(() => {
                    console.log('Running initial counter validation...');
                    validateDeviceCounters();
                }, 10000); // 10 seconds after startup

                // Make functions available globally for manual console queries
                window.queryLastTemperatures = queryLastTemperatures;
                window.generatePDFReport = generatePDFReport;
                window.getReportStatistics = getReportStatistics;
                window.checkFirebaseConnection = checkFirebaseConnection;
                window.resetDeviceCounters = resetDeviceCounters;
                window.validateDeviceCounters = validateDeviceCounters;
                window.getTemperatureSummaryByZone = getTemperatureSummaryByZone;
                window.getTemperatureClassificationReport = getTemperatureClassificationReport;
                window.getCriticalOfflineDevices = getCriticalOfflineDevices;
                window.getDataUsageStats = getDataUsageStats;
                window.validateDeviceCounters = validateDeviceCounters;
                window.resetDeviceCounters = resetDeviceCounters;
                window.cleanupCache = cleanupCache;
                window.cleanupDeviceListeners = cleanupDeviceListeners;
                window.deviceData = deviceData;
                window.deviceList = deviceList;
                window.dataCache = dataCache;

                console.log('All device listeners started successfully');
                console.log('Available console commands:');
                console.log('- queryLastTemperatures(): Get current temperature readings');
                console.log('- generatePDFReport(): Export last temperature report to PDF');
                console.log('- getReportStatistics(): Get summary statistics of last report');
                console.log('- checkFirebaseConnection(): Debug Firebase connectivity');
                console.log('- resetDeviceCounters(): Reset and recalculate device counters');
                console.log('- validateDeviceCounters(): Validate device counter accuracy');
                console.log('- getTemperatureSummaryByZone(): Get temperature summary by zone');
                console.log('- getTemperatureClassificationReport(): Get temperature classification by ranges');
                console.log('- getCriticalOfflineDevices(): Get devices offline >30 minutes');
                console.log('- getDataUsageStats(): Get enhanced data usage and optimization statistics');
                console.log('- validateDeviceCounters(): Check counter accuracy');
                console.log('- resetDeviceCounters(): Reset and recalculate counters');
                console.log('- cleanupCache(): Manually cleanup cache');
                console.log('- cleanupDeviceListeners(): Cleanup all Firebase listeners');
                console.log('- deviceData: Access raw device data');
                console.log('- deviceList: Access current device list');
                console.log('- dataCache: Access cache data');
                console.log('📊 Data optimization is ACTIVE - Firebase usage minimized!');
                console.log('🔴 Red cards will appear for devices offline >30 minutes');
                console.log('⚡ LATEST DATA ONLY MODE - Using minimal Firebase queries!');
                console.log('🌡️ Temperature color coding: Cold(<2°C)=Blue, Optimal(2-8°C)=Green, Hot(>8°C)=Red');
                
            } catch (error) {
                console.error('Error starting application:', error);
                const container = document.getElementById('device-cards-container');
                container.innerHTML = `
                    <div class="col-12 text-center">
                        <div class="alert alert-danger" role="alert">
                            <i class="fas fa-exclamation-circle fa-2x mb-3"></i>
                            <h4>เกิดข้อผิดพลาด</h4>
                            <p class="mb-0">ไม่สามารถเชื่อมต่อกับฐานข้อมูลได้: ${error.message}</p>
                        </div>
                    </div>
                `;
            }
        }

        // Start the application
        startApp();
    </script>
</body>

</html>