<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Monitor Dashboard</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .dashboard-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .device-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: none;
        }

        .device-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .device-card.offline-critical {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
            border: 2px solid #e74c3c;
            box-shadow: 0 4px 20px rgba(231, 76, 60, 0.3);
        }

        .device-card.offline-critical:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(231, 76, 60, 0.4);
        }

        .device-card.offline-critical .device-id {
            color: white;
        }

        .device-card.offline-critical .device-id i {
            color: #ffcccb;
        }

        .device-card.offline-critical .device-type {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .device-card.offline-critical .temp-reading {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .device-card.offline-critical .temp-label {
            color: #ffcccb;
        }

        .device-card.offline-critical .temp-value {
            color: white;
        }

        .device-card.offline-critical .ip-address {
            color: #ffcccb;
        }

        .device-card.offline-critical .last-update {
            color: #ffcccb;
        }

        .device-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e9ecef;
        }

        .device-id {
            font-size: 1.2rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .device-id i {
            margin-right: 0.5rem;
            color: #3498db;
        }

        .status-online {
            background-color: #27ae60;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .status-offline {
            background-color: #e74c3c;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .device-type {
            background-color: #ecf0f1;
            color: #2c3e50;
            padding: 0.25rem 0.75rem;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 1rem;
            display: inline-block;
        }

        .temp-reading {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding: 0.5rem;
            background-color: #f8f9fa;
            border-radius: 6px;
        }

        .temp-label {
            color: #6c757d;
            font-size: 0.9rem;
        }

        .temp-value {
            font-weight: 600;
            color: #2c3e50;
        }

        .temp-value.error {
            color: #e74c3c;
        }

        .temp-value.normal {
            color: #27ae60;
        }

        .ip-address {
            color: #6c757d;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .last-update {
            color: #95a5a6;
            font-size: 0.8rem;
            text-align: right;
        }

        .stats-bar {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9rem;
        }

        .online-stat {
            color: #27ae60;
        }

        .offline-stat {
            color: #e74c3c;
        }
    </style>
</head>

<body>
    <div class="dashboard-header">
        <div class="container">
            <div class="row">
                <div class="col-12 text-center">
                    <h1 class="mb-0">
                        <i class="fas fa-thermometer-half me-3"></i>
                        Temperature Monitor Dashboard
                    </h1>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Statistics Bar -->
        <div class="stats-bar">
            <div class="row">
                <div class="col-md-2">
                    <div class="stat-item total-devices">
                        <div class="stat-number">8</div>
                        <div class="stat-label">Total Devices</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="stat-item online-devices">
                        <div class="stat-number online-stat">0</div>
                        <div class="stat-label">Online</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="stat-item offline-devices">
                        <div class="stat-number offline-stat">0</div>
                        <div class="stat-label">Offline</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="stat-item">
                        <button class="btn btn-primary btn-sm" onclick="queryLastTemperatures()" title="Query Latest Temperature Data">
                            <i class="fas fa-search me-2"></i>Query Temps
                        </button>
                        <div class="stat-label mt-1">
                            <small id="last-query-time">Never queried</small>
                        </div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="stat-item">
                        <button class="btn btn-success btn-sm" onclick="validateDeviceCounters()" title="Validate Device Counters">
                            <i class="fas fa-check-circle me-2"></i>Check Count
                        </button>
                        <div class="stat-label mt-1">
                            <small class="text-success">
                                <i class="fas fa-calculator me-1"></i>Validate
                            </small>
                        </div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="stat-item">
                        <button class="btn btn-info btn-sm" onclick="getDataUsageStats()" title="Data Usage Statistics">
                            <i class="fas fa-chart-bar me-2"></i>Data Stats
                        </button>
                        <div class="stat-label mt-1">
                            <small class="text-success">
                                <i class="fas fa-leaf me-1"></i>Optimized
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Device Cards Container -->
        <div class="row" id="device-cards-container">
            <!-- Device cards will be dynamically generated here -->
            <div class="col-12 text-center">
                <div class="loading-message" style="padding: 3rem;">
                    <i class="fas fa-spinner fa-spin fa-2x text-primary mb-3"></i>
                    <h4>กำลังโหลดข้อมูลอุปกรณ์...</h4>
                    <p class="text-muted">กำลังเชื่อมต่อกับ Firebase และดึงรายการอุปกรณ์</p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getDatabase, ref, onValue, query, orderByChild, limitToLast } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-database.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBtj8Jl6tRJyRUef145AtGvSADh37xSVSs",
            authDomain: "tempsskh-f4318.firebaseapp.com",
            databaseURL: "https://tempsskh-f4318-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "tempsskh-f4318",
            storageBucket: "tempsskh-f4318.firebasestorage.app",
            messagingSenderId: "989516171136",
            appId: "1:989516171136:web:64cb3d46e3a546dd0c2365",
            measurementId: "G-97L0RL7NP7"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Define the specific devices to monitor (will be populated from database)
        let deviceList = [];

        // Store device data and state
        const deviceData = {};
        let onlineCount = 0;
        let offlineCount = 0;
        
        // Data optimization settings
        const DATA_OPTIMIZATION = {
            maxLogEntries: 50,        // Keep only last 50 entries per device
            cleanupInterval: 300000,  // Clean old data every 5 minutes
            onlineThreshold: 300,     // 5 minutes in seconds
            maxDataAge: 86400,        // 24 hours in seconds
            batchSize: 10,            // Process devices in batches
            useCompression: true,     // Enable data compression
            cacheTimeout: 60000       // Cache timeout 1 minute
        };

        // Cache for reducing duplicate queries
        const dataCache = new Map();
        
        // Listener references for cleanup
        const deviceListeners = new Map();

        // Function to create device card HTML
        function createDeviceCard(deviceId) {
            const zone = deviceId.split('-')[0]; // Extract zone from device ID
            return `
                <div class="col-lg-3 col-md-6 mb-4">
                    <div class="device-card" data-device-id="${deviceId}">
                        <div class="device-header">
                            <div class="device-id">
                                <i class="fas fa-microchip"></i>
                                ${deviceId}
                            </div>
                            <span class="status-badge status-offline">กำลังโหลด...</span>
                        </div>
                        <div class="device-type">${zone}</div>
                        <div class="offline-duration" style="display: none;">
                            <small class="text-warning">
                                <i class="fas fa-clock me-1"></i>
                                <span class="duration-text">Offline for: -</span>
                            </small>
                        </div>
                        <div class="temp-reading">
                            <span class="temp-label">อุณหภูมิ 1:</span>
                            <span class="temp-value temp1-value">-</span>
                        </div>
                        <div class="temp-reading">
                            <span class="temp-label">อุณหภูมิ 2:</span>
                            <span class="temp-value temp2-value">-</span>
                        </div>
                        <div class="ip-address">
                            <i class="fas fa-network-wired me-2"></i>
                            IP Address: -
                        </div>
                        <div class="last-update">
                            อัปเดตล่าสุด: กำลังโหลด...
                        </div>
                    </div>
                </div>
            `;
        }

        // Function to render device cards
        function renderDeviceCards() {
            const container = document.getElementById('device-cards-container');
            const cardsHTML = deviceList.map(deviceId => createDeviceCard(deviceId)).join('');

            container.innerHTML = cardsHTML;

            // Add click handlers for device cards
            container.querySelectorAll('.device-card').forEach(card => {
                card.addEventListener('click', function () {
                    const deviceId = this.getAttribute('data-device-id');
                    console.log(`Clicked on device: ${deviceId}`, deviceData[deviceId]);
                });
            });
        }

        // Function to determine if device is online (data received within last 5 minutes)
        function isDeviceOnline(timestamp) {
            const now = Math.floor(Date.now() / 1000);
            const deviceTime = parseInt(timestamp);
            return (now - deviceTime) < DATA_OPTIMIZATION.onlineThreshold;
        }

        // Function to determine if device is critically offline (over 30 minutes)
        function isDeviceCriticallyOffline(timestamp) {
            if (!timestamp) return true;
            const now = Math.floor(Date.now() / 1000);
            const deviceTime = parseInt(timestamp);
            const thirtyMinutes = 30 * 60; // 30 minutes in seconds
            return (now - deviceTime) > thirtyMinutes;
        }

        // Function to get offline duration in minutes
        function getOfflineDuration(timestamp) {
            if (!timestamp) return null;
            const now = Math.floor(Date.now() / 1000);
            const deviceTime = parseInt(timestamp);
            const durationSeconds = now - deviceTime;
            return Math.floor(durationSeconds / 60); // Return minutes
        }

        // Function to check if data is fresh (within cache timeout)
        function isDataFresh(cacheKey) {
            const cached = dataCache.get(cacheKey);
            if (!cached) return false;
            
            const now = Date.now();
            return (now - cached.timestamp) < DATA_OPTIMIZATION.cacheTimeout;
        }

        // Function to compress data object (remove unnecessary fields)
        function compressDeviceData(data) {
            if (!DATA_OPTIMIZATION.useCompression) return data;
            
            return {
                t1: data.temp1,           // temp1 -> t1
                t2: data.temp2,           // temp2 -> t2
                s1: data.status_temp1,    // status_temp1 -> s1
                s2: data.status_temp2,    // status_temp2 -> s2
                ip: data.ip,
                ts: data.timestamp,       // timestamp -> ts
                dt: data.datetime         // datetime -> dt (keep for display)
            };
        }

        // Function to decompress data object
        function decompressDeviceData(compressed) {
            if (!DATA_OPTIMIZATION.useCompression) return compressed;
            
            return {
                temp1: compressed.t1,
                temp2: compressed.t2,
                status_temp1: compressed.s1,
                status_temp2: compressed.s2,
                ip: compressed.ip,
                timestamp: compressed.ts,
                datetime: compressed.dt
            };
        }

        // Function to format temperature value
        function formatTemperature(temp, status) {
            if (status === "SENSOR_ERROR" || temp === -127) {
                return "Error";
            }
            return `${temp}°C`;
        }

        // Function to get temperature CSS class
        function getTemperatureClass(temp, status) {
            if (status === "SENSOR_ERROR" || temp === -127) {
                return "error";
            }
            return "normal";
        }

        // Function to update device card
        function updateDeviceCard(deviceId, data) {
            const cardElement = document.querySelector(`[data-device-id="${deviceId}"]`);
            if (!cardElement) return;

            const isOnline = isDeviceOnline(data.timestamp);
            const isCriticallyOffline = isDeviceCriticallyOffline(data.timestamp);
            const offlineDuration = getOfflineDuration(data.timestamp);

            // Update card styling based on critical offline status
            if (isCriticallyOffline && !isOnline) {
                cardElement.classList.add('offline-critical');
            } else {
                cardElement.classList.remove('offline-critical');
            }

            // Update status badge
            const statusBadge = cardElement.querySelector('.status-badge');
            if (statusBadge) {
                if (isOnline) {
                    statusBadge.textContent = 'ออนไลน์';
                    statusBadge.className = 'status-badge status-online';
                } else if (isCriticallyOffline) {
                    statusBadge.textContent = 'ออฟไลน์ (Critical)';
                    statusBadge.className = 'status-badge status-offline';
                    statusBadge.style.backgroundColor = '#c0392b';
                } else {
                    statusBadge.textContent = 'ออฟไลน์';
                    statusBadge.className = 'status-badge status-offline';
                    statusBadge.style.backgroundColor = '#e74c3c';
                }
            }

            // Update offline duration display
            const offlineDurationElement = cardElement.querySelector('.offline-duration');
            if (offlineDurationElement) {
                if (!isOnline && offlineDuration !== null) {
                    const durationText = cardElement.querySelector('.duration-text');
                    if (durationText) {
                        if (offlineDuration < 60) {
                            durationText.textContent = `Offline for: ${offlineDuration}m`;
                        } else {
                            const hours = Math.floor(offlineDuration / 60);
                            const minutes = offlineDuration % 60;
                            durationText.textContent = `Offline for: ${hours}h ${minutes}m`;
                        }
                    }
                    offlineDurationElement.style.display = 'block';
                    
                    // Change color based on duration
                    if (isCriticallyOffline) {
                        offlineDurationElement.className = 'offline-duration';
                        offlineDurationElement.innerHTML = `
                            <small class="text-light">
                                <i class="fas fa-exclamation-triangle me-1"></i>
                                <span class="duration-text">Offline for: ${offlineDuration < 60 ? offlineDuration + 'm' : Math.floor(offlineDuration / 60) + 'h ' + (offlineDuration % 60) + 'm'}</span>
                            </small>
                        `;
                    } else {
                        offlineDurationElement.innerHTML = `
                            <small class="text-warning">
                                <i class="fas fa-clock me-1"></i>
                                <span class="duration-text">Offline for: ${offlineDuration < 60 ? offlineDuration + 'm' : Math.floor(offlineDuration / 60) + 'h ' + (offlineDuration % 60) + 'm'}</span>
                            </small>
                        `;
                    }
                } else {
                    offlineDurationElement.style.display = 'none';
                }
            }

            // Update device zone
            const deviceType = cardElement.querySelector('.device-type');
            if (deviceType) {
                deviceType.textContent = data.zone || deviceId.split('-')[0];
            }

            // Update temperature 1
            const temp1Element = cardElement.querySelector('.temp1-value');
            if (temp1Element) {
                temp1Element.textContent = formatTemperature(data.temp1, data.status_temp1);
                temp1Element.className = `temp-value ${getTemperatureClass(data.temp1, data.status_temp1)}`;
            }

            // Update temperature 2
            const temp2Element = cardElement.querySelector('.temp2-value');
            if (temp2Element) {
                temp2Element.textContent = formatTemperature(data.temp2, data.status_temp2);
                temp2Element.className = `temp-value ${getTemperatureClass(data.temp2, data.status_temp2)}`;
            }

            // Update IP address
            const ipElement = cardElement.querySelector('.ip-address');
            if (ipElement) {
                ipElement.innerHTML = `<i class="fas fa-network-wired me-2"></i>IP Address: ${data.ip || '-'}`;
            }

            // Update last update time
            const lastUpdateElement = cardElement.querySelector('.last-update');
            if (lastUpdateElement) {
                lastUpdateElement.textContent = `อัปเดตล่าสุด: ${data.datetime || '-'}`;
            }
        }

        // Function to update statistics
        function updateStatistics() {
            document.querySelector('.total-devices .stat-number').textContent = deviceList.length;
            document.querySelector('.online-devices .stat-number').textContent = onlineCount;
            document.querySelector('.offline-devices .stat-number').textContent = offlineCount;
        }

        // Function to recalculate and validate device counters
        function validateDeviceCounters() {
            let actualOnline = 0;
            let actualOffline = 0;
            let criticalOffline = 0;
            
            Object.values(deviceData).forEach(data => {
                if (data && data.timestamp) {
                    if (isDeviceOnline(data.timestamp)) {
                        actualOnline++;
                    } else {
                        actualOffline++;
                        if (isDeviceCriticallyOffline(data.timestamp)) {
                            criticalOffline++;
                        }
                    }
                }
            });
            
            // Check for devices without data
            const devicesWithoutData = deviceList.filter(deviceId => !deviceData[deviceId]);
            actualOffline += devicesWithoutData.length;
            criticalOffline += devicesWithoutData.length; // Assume devices without data are critically offline
            
            // Validate and correct if needed
            if (onlineCount !== actualOnline || offlineCount !== actualOffline) {
                console.warn(`Counter mismatch detected!`);
                console.warn(`Expected: Online=${onlineCount}, Offline=${offlineCount}`);
                console.warn(`Actual: Online=${actualOnline}, Offline=${actualOffline}`);
                console.warn(`Critical Offline: ${criticalOffline}`);
                console.warn(`Correcting counters...`);
                
                onlineCount = actualOnline;
                offlineCount = actualOffline;
                updateStatistics();
            }
            
            // Validate total count
            const totalCount = onlineCount + offlineCount;
            if (totalCount !== deviceList.length) {
                console.warn(`Total count mismatch: ${totalCount} vs ${deviceList.length}`);
                console.warn(`Devices without data:`, devicesWithoutData);
            }
            
            // Log critical offline devices
            if (criticalOffline > 0) {
                console.warn(`⚠️  ${criticalOffline} devices are critically offline (>30 minutes)`);
            }
            
            return {
                online: onlineCount,
                offline: offlineCount,
                criticalOffline: criticalOffline,
                total: deviceList.length,
                actualOnline,
                actualOffline,
                isValid: onlineCount === actualOnline && offlineCount === actualOffline
            };
        }

        // Function to reset and recalculate all counters
        function resetDeviceCounters() {
            console.log('Resetting device counters...');
            onlineCount = 0;
            offlineCount = 0;
            
            deviceList.forEach(deviceId => {
                const data = deviceData[deviceId];
                if (data && data.timestamp) {
                    if (isDeviceOnline(data.timestamp)) {
                        onlineCount++;
                    } else {
                        offlineCount++;
                    }
                } else {
                    offlineCount++;
                }
            });
            
            updateStatistics();
            console.log(`Counters reset - Online: ${onlineCount}, Offline: ${offlineCount}`);
            
            return validateDeviceCounters();
        }

        // Function to query and display last temperature readings from all devices
        function queryLastTemperatures() {
            const queryTime = new Date();
            const queryTimeString = queryTime.toLocaleString('th-TH');
            
            console.log('=== LAST TEMPERATURE MONITORING REPORT ===');
            console.log('Query Time:', queryTimeString);
            console.log('----------------------------------------');
            
            // Update UI with last query time
            const lastQueryElement = document.getElementById('last-query-time');
            if (lastQueryElement) {
                lastQueryElement.textContent = `Last: ${queryTime.toLocaleTimeString('th-TH')}`;
            }
            
            if (deviceList.length === 0) {
                console.log('No devices found in database');
                return;
            }

            const temperatureReport = [];
            
            deviceList.forEach(deviceId => {
                const data = deviceData[deviceId];
                if (data) {
                    const isOnline = isDeviceOnline(data.timestamp);
                    const isCriticallyOffline = isDeviceCriticallyOffline(data.timestamp);
                    const offlineDuration = getOfflineDuration(data.timestamp);
                    const temp1Status = data.status_temp1 === "SENSOR_ERROR" ? "ERROR" : "OK";
                    const temp2Status = data.status_temp2 === "SENSOR_ERROR" ? "ERROR" : "OK";
                    
                    const deviceReport = {
                        deviceId: deviceId,
                        zone: data.zone || deviceId.split('-')[0],
                        status: isOnline ? 'ONLINE' : (isCriticallyOffline ? 'CRITICAL_OFFLINE' : 'OFFLINE'),
                        temp1: data.temp1 === -127 ? 'ERROR' : `${data.temp1}°C`,
                        temp1Status: temp1Status,
                        temp2: data.temp2 === -127 ? 'ERROR' : `${data.temp2}°C`,
                        temp2Status: temp2Status,
                        ip: data.ip || 'N/A',
                        lastUpdate: data.datetime || 'N/A',
                        timestamp: data.timestamp,
                        offlineDuration: offlineDuration
                    };
                    
                    temperatureReport.push(deviceReport);
                    
                    console.log(`Device: ${deviceId}`);
                    console.log(`  Zone: ${deviceReport.zone}`);
                    console.log(`  Status: ${deviceReport.status}`);
                    if (!isOnline && offlineDuration !== null) {
                        console.log(`  Offline Duration: ${offlineDuration} minutes`);
                    }
                    console.log(`  Temperature 1: ${deviceReport.temp1} (${temp1Status})`);
                    console.log(`  Temperature 2: ${deviceReport.temp2} (${temp2Status})`);
                    console.log(`  IP Address: ${deviceReport.ip}`);
                    console.log(`  Last Update: ${deviceReport.lastUpdate}`);
                    console.log('  ---');
                } else {
                    console.log(`Device: ${deviceId} - NO DATA RECEIVED`);
                    temperatureReport.push({
                        deviceId: deviceId,
                        zone: deviceId.split('-')[0],
                        status: 'NO_DATA',
                        temp1: 'N/A',
                        temp1Status: 'N/A',
                        temp2: 'N/A',
                        temp2Status: 'N/A',
                        ip: 'N/A',
                        lastUpdate: 'N/A',
                        timestamp: null,
                        offlineDuration: null
                    });
                }
            });
            
            console.log('----------------------------------------');
            console.log(`Total Devices: ${deviceList.length}`);
            console.log(`Online Devices: ${onlineCount}`);
            console.log(`Offline Devices: ${offlineCount}`);
            console.log('=== END OF TEMPERATURE REPORT ===');
            
            return temperatureReport;
        }

        // Function to get temperature summary for specific zones
        function getTemperatureSummaryByZone() {
            const zoneSummary = {};
            
            deviceList.forEach(deviceId => {
                const data = deviceData[deviceId];
                const zone = data?.zone || deviceId.split('-')[0];
                
                if (!zoneSummary[zone]) {
                    zoneSummary[zone] = {
                        devices: [],
                        onlineCount: 0,
                        offlineCount: 0,
                        avgTemp1: 0,
                        avgTemp2: 0,
                        validTemp1Count: 0,
                        validTemp2Count: 0
                    };
                }
                
                zoneSummary[zone].devices.push(deviceId);
                
                if (data) {
                    const isOnline = isDeviceOnline(data.timestamp);
                    if (isOnline) {
                        zoneSummary[zone].onlineCount++;
                    } else {
                        zoneSummary[zone].offlineCount++;
                    }
                    
                    // Calculate average temperatures (excluding errors)
                    if (data.temp1 !== -127 && data.status_temp1 !== "SENSOR_ERROR") {
                        zoneSummary[zone].avgTemp1 += data.temp1;
                        zoneSummary[zone].validTemp1Count++;
                    }
                    
                    if (data.temp2 !== -127 && data.status_temp2 !== "SENSOR_ERROR") {
                        zoneSummary[zone].avgTemp2 += data.temp2;
                        zoneSummary[zone].validTemp2Count++;
                    }
                } else {
                    zoneSummary[zone].offlineCount++;
                }
            });
            
            // Calculate averages
            Object.keys(zoneSummary).forEach(zone => {
                if (zoneSummary[zone].validTemp1Count > 0) {
                    zoneSummary[zone].avgTemp1 = (zoneSummary[zone].avgTemp1 / zoneSummary[zone].validTemp1Count).toFixed(1);
                } else {
                    zoneSummary[zone].avgTemp1 = 'N/A';
                }
                
                if (zoneSummary[zone].validTemp2Count > 0) {
                    zoneSummary[zone].avgTemp2 = (zoneSummary[zone].avgTemp2 / zoneSummary[zone].validTemp2Count).toFixed(1);
                } else {
                    zoneSummary[zone].avgTemp2 = 'N/A';
                }
            });
            
            console.log('=== TEMPERATURE SUMMARY BY ZONE ===');
            Object.entries(zoneSummary).forEach(([zone, summary]) => {
                console.log(`Zone: ${zone}`);
                console.log(`  Devices: ${summary.devices.join(', ')}`);
                console.log(`  Online: ${summary.onlineCount}, Offline: ${summary.offlineCount}`);
                console.log(`  Average Temp1: ${summary.avgTemp1}°C`);
                console.log(`  Average Temp2: ${summary.avgTemp2}°C`);
                console.log('  ---');
            });
            
            return zoneSummary;
        }

        // Function to get critically offline devices (>30 minutes)
        function getCriticalOfflineDevices() {
            const criticalDevices = [];
            
            deviceList.forEach(deviceId => {
                const data = deviceData[deviceId];
                if (data && data.timestamp) {
                    if (isDeviceCriticallyOffline(data.timestamp) && !isDeviceOnline(data.timestamp)) {
                        const offlineDuration = getOfflineDuration(data.timestamp);
                        criticalDevices.push({
                            deviceId: deviceId,
                            zone: data.zone || deviceId.split('-')[0],
                            offlineDuration: offlineDuration,
                            offlineDurationText: offlineDuration < 60 ? `${offlineDuration}m` : `${Math.floor(offlineDuration / 60)}h ${offlineDuration % 60}m`,
                            lastUpdate: data.datetime || 'N/A',
                            timestamp: data.timestamp
                        });
                    }
                } else {
                    // Device without data is considered critically offline
                    criticalDevices.push({
                        deviceId: deviceId,
                        zone: deviceId.split('-')[0],
                        offlineDuration: null,
                        offlineDurationText: 'No data',
                        lastUpdate: 'Never',
                        timestamp: null
                    });
                }
            });
            
            // Sort by offline duration (longest first)
            criticalDevices.sort((a, b) => {
                if (a.offlineDuration === null) return 1;
                if (b.offlineDuration === null) return -1;
                return b.offlineDuration - a.offlineDuration;
            });
            
            console.log('=== CRITICAL OFFLINE DEVICES (>30 minutes) ===');
            if (criticalDevices.length === 0) {
                console.log('✅ No critically offline devices found');
            } else {
                console.log(`⚠️  Found ${criticalDevices.length} critically offline devices:`);
                criticalDevices.forEach(device => {
                    console.log(`  ${device.deviceId} (${device.zone}) - Offline: ${device.offlineDurationText}`);
                });
            }
            console.log('===============================================');
            
            return criticalDevices;
        }

        // Function to cleanup old cache entries
        function cleanupCache() {
            const now = Date.now();
            const keysToDelete = [];
            
            dataCache.forEach((value, key) => {
                const age = now - value.timestamp;
                if (age > DATA_OPTIMIZATION.cacheTimeout * 2) { // Double the timeout for cleanup
                    keysToDelete.push(key);
                }
            });
            
            keysToDelete.forEach(key => {
                dataCache.delete(key);
            });
            
            if (keysToDelete.length > 0) {
                console.log(`Cleaned up ${keysToDelete.length} cache entries`);
            }
        }

        // Function to cleanup device listeners
        function cleanupDeviceListeners() {
            deviceListeners.forEach((unsubscribe, deviceId) => {
                if (unsubscribe && typeof unsubscribe === 'function') {
                    unsubscribe();
                    console.log(`Cleaned up listener for ${deviceId}`);
                }
            });
            deviceListeners.clear();
        }

        // Function to get data usage statistics
        function getDataUsageStats() {
            const stats = {
                cacheSize: dataCache.size,
                activeListeners: deviceListeners.size,
                deviceDataSize: Object.keys(deviceData).length,
                optimizationSettings: DATA_OPTIMIZATION
            };
            
            console.log('=== DATA USAGE STATISTICS ===');
            console.log('Cache entries:', stats.cacheSize);
            console.log('Active listeners:', stats.activeListeners);
            console.log('Device data entries:', stats.deviceDataSize);
            console.log('Optimization settings:', stats.optimizationSettings);
            console.log('==============================');
            
            return stats;
        }

        // Handle page unload to cleanup connections
        window.addEventListener('beforeunload', () => {
            console.log('Cleaning up Firebase connections...');
            cleanupDeviceListeners();
        });

        // Optimized function to fetch devices with caching
        function fetchAllDevices() {
            return new Promise((resolve, reject) => {
                const cacheKey = 'deviceList';
                
                // Check cache first
                if (isDataFresh(cacheKey)) {
                    console.log('Using cached device list');
                    resolve(dataCache.get(cacheKey).data);
                    return;
                }
                
                const devicesRef = ref(database, 'devices');
                
                onValue(devicesRef, (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        const devices = Object.keys(data);
                        
                        // Cache the result
                        dataCache.set(cacheKey, {
                            data: devices,
                            timestamp: Date.now()
                        });
                        
                        console.log('Found devices in database:', devices);
                        resolve(devices);
                    } else {
                        console.log('No devices found in database');
                        resolve([]);
                    }
                }, (error) => {
                    console.error('Error fetching devices:', error);
                    reject(error);
                }, { once: true });
            });
        }

        // Optimized function to clean old log entries
        function cleanOldLogEntries(deviceId) {
            const deviceLogRef = ref(database, `devices/${deviceId}/log`);
            
            onValue(deviceLogRef, (snapshot) => {
                const logData = snapshot.val();
                if (logData) {
                    const entries = Object.entries(logData);
                    
                    // Sort by timestamp (newest first)
                    entries.sort((a, b) => parseInt(b[1].timestamp) - parseInt(a[1].timestamp));
                    
                    // Keep only the latest entries
                    if (entries.length > DATA_OPTIMIZATION.maxLogEntries) {
                        const entriesToDelete = entries.slice(DATA_OPTIMIZATION.maxLogEntries);
                        console.log(`Cleaning ${entriesToDelete.length} old entries for ${deviceId}`);
                        
                        // Note: In a real implementation, you would delete these entries
                        // For now, we'll just log the cleanup action
                        // This requires Firebase Admin SDK or Cloud Functions
                    }
                    
                    // Remove very old entries (older than maxDataAge)
                    const now = Math.floor(Date.now() / 1000);
                    const oldEntries = entries.filter(([key, data]) => {
                        const age = now - parseInt(data.timestamp);
                        return age > DATA_OPTIMIZATION.maxDataAge;
                    });
                    
                    if (oldEntries.length > 0) {
                        console.log(`Found ${oldEntries.length} entries older than 24 hours for ${deviceId}`);
                    }
                }
            }, { once: true });
        }

        // Function to check for new devices periodically
        function monitorDeviceChanges() {
            const devicesRef = ref(database, 'devices');
            
            onValue(devicesRef, async (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const currentDevices = Object.keys(data);
                    const newDevices = currentDevices.filter(device => !deviceList.includes(device));
                    const removedDevices = deviceList.filter(device => !currentDevices.includes(device));
                    
                    if (newDevices.length > 0 || removedDevices.length > 0) {
                        console.log('Device list changed. New devices:', newDevices, 'Removed devices:', removedDevices);
                        
                        // Update device list
                        deviceList = currentDevices;
                        
                        // Update total devices count
                        document.querySelector('.total-devices .stat-number').textContent = deviceList.length;
                        
                        // Re-render all cards
                        renderDeviceCards();
                        
                        // Start listening to new devices
                        newDevices.forEach(deviceId => {
                            listenToDevice(deviceId);
                        });
                        
                        // Clean up removed devices from deviceData
                        removedDevices.forEach(deviceId => {
                            if (deviceData[deviceId]) {
                                delete deviceData[deviceId];
                            }
                        });
                        
                        // Recalculate statistics
                        onlineCount = 0;
                        offlineCount = 0;
                        Object.values(deviceData).forEach(data => {
                            if (isDeviceOnline(data.timestamp)) {
                                onlineCount++;
                            } else {
                                offlineCount++;
                            }
                        });
                        updateStatistics();
                    }
                }
            });
        }

        // Optimized function to listen to device data with minimal reads
        function listenToDevice(deviceId) {
            const cacheKey = `device_${deviceId}`;
            
            // Check if we already have a listener for this device
            if (deviceListeners.has(deviceId)) {
                console.log(`Listener already exists for ${deviceId}`);
                return;
            }
            
            // Use orderByChild and limitToLast to get only the latest entry
            const deviceLogRef = ref(database, `devices/${deviceId}/log`);
            
            // Create a query to get only the latest entries
            const latestQuery = query(
                deviceLogRef,
                orderByChild('timestamp'),
                limitToLast(5) // Get only last 5 entries to reduce data transfer
            );
            
            const unsubscribe = onValue(latestQuery, (snapshot) => {
                const logData = snapshot.val();
                if (logData) {
                    // Find the latest entry by timestamp
                    let latestData = null;
                    let latestTimestamp = 0;

                    Object.values(logData).forEach(entry => {
                        if (entry.timestamp && parseInt(entry.timestamp) > latestTimestamp) {
                            latestTimestamp = parseInt(entry.timestamp);
                            latestData = entry;
                        }
                    });

                    if (latestData) {
                        // Check cache to avoid unnecessary updates
                        const cached = dataCache.get(cacheKey);
                        if (cached && cached.data.timestamp === latestData.timestamp) {
                            return; // No change, skip update
                        }
                        
                        // Compress data for storage
                        const compressedData = compressDeviceData(latestData);
                        
                        // Update cache
                        dataCache.set(cacheKey, {
                            data: compressedData,
                            timestamp: Date.now()
                        });

                        const wasOnline = deviceData[deviceId] ? isDeviceOnline(deviceData[deviceId].timestamp) : false;
                        const isOnline = isDeviceOnline(latestData.timestamp);

                        // Update online/offline counts
                        if (wasOnline && !isOnline) {
                            onlineCount--;
                            offlineCount++;
                        } else if (!wasOnline && isOnline) {
                            onlineCount++;
                            offlineCount--;
                        } else if (!deviceData[deviceId]) {
                            // First time loading this device
                            if (isOnline) {
                                onlineCount++;
                            } else {
                                offlineCount++;
                            }
                        }

                        // Store decompressed data for UI
                        deviceData[deviceId] = decompressDeviceData(compressedData);
                        updateDeviceCard(deviceId, deviceData[deviceId]);
                        updateStatistics();

                        console.log(`Updated ${deviceId} (optimized):`, deviceData[deviceId]);
                        
                        // Validate counters periodically (every 10th update)
                        if (Math.random() < 0.1) {
                            validateDeviceCounters();
                        }
                    }
                } else {
                    console.log(`No log data found for ${deviceId}`);
                    if (deviceData[deviceId] && isDeviceOnline(deviceData[deviceId].timestamp)) {
                        onlineCount--;
                        offlineCount++;
                        updateStatistics();
                    }
                }
            }, (error) => {
                console.error(`Error listening to ${deviceId}/log:`, error);
                if (deviceData[deviceId] && isDeviceOnline(deviceData[deviceId].timestamp)) {
                    onlineCount--;
                    offlineCount++;
                    updateStatistics();
                }
            });
            
            // Store listener reference for cleanup
            deviceListeners.set(deviceId, unsubscribe);
        }

        // Initialize the application
        async function startApp() {
            console.log('Initializing Temperature Monitor Dashboard...');
            
            try {
                // Fetch all devices from database
                deviceList = await fetchAllDevices();
                
                if (deviceList.length === 0) {
                    console.warn('No devices found in database');
                    const container = document.getElementById('device-cards-container');
                    container.innerHTML = `
                        <div class="col-12 text-center">
                            <div class="alert alert-warning" role="alert">
                                <i class="fas fa-exclamation-triangle fa-2x mb-3"></i>
                                <h4>ไม่พบอุปกรณ์</h4>
                                <p class="mb-0">ไม่มีอุปกรณ์ในฐานข้อมูล กรุณาตรวจสอบการเชื่อมต่อ</p>
                            </div>
                        </div>
                    `;
                    return;
                }
                
                console.log('Monitoring devices:', deviceList);
                
                // Update total devices count
                document.querySelector('.total-devices .stat-number').textContent = deviceList.length;

                // Render device cards
                renderDeviceCards();

                // Start listening to devices in batches to reduce simultaneous connections
                const batchSize = DATA_OPTIMIZATION.batchSize;
                for (let i = 0; i < deviceList.length; i += batchSize) {
                    const batch = deviceList.slice(i, i + batchSize);
                    
                    // Add delay between batches to avoid overwhelming Firebase
                    setTimeout(() => {
                        console.log(`Starting batch ${Math.floor(i/batchSize) + 1}:`, batch);
                        batch.forEach(deviceId => {
                            listenToDevice(deviceId);
                        });
                    }, (i / batchSize) * 1000); // 1 second delay between batches
                }

                // Start monitoring for device changes (less frequent)
                setTimeout(() => {
                    monitorDeviceChanges();
                }, 5000); // Delay device monitoring

                // Start periodic temperature monitoring (reduced frequency)
                setInterval(() => {
                    queryLastTemperatures();
                }, 60000); // Every 60 seconds instead of 30

                // Start periodic cache cleanup
                setInterval(() => {
                    cleanupCache();
                }, DATA_OPTIMIZATION.cleanupInterval);

                // Start periodic log cleanup (check every 10 minutes)
                setInterval(() => {
                    if (deviceList.length > 0) {
                        const randomDevice = deviceList[Math.floor(Math.random() * deviceList.length)];
                        cleanOldLogEntries(randomDevice);
                    }
                }, 600000); // 10 minutes

                // Start periodic counter validation (every 2 minutes)
                setInterval(() => {
                    console.log('Running periodic counter validation...');
                    const validation = validateDeviceCounters();
                    if (!validation.isValid) {
                        console.warn('Counter validation failed, resetting...');
                        resetDeviceCounters();
                    }
                }, 120000); // 2 minutes

                // Initial counter validation after startup
                setTimeout(() => {
                    console.log('Running initial counter validation...');
                    validateDeviceCounters();
                }, 10000); // 10 seconds after startup

                // Make functions available globally for manual console queries
                window.queryLastTemperatures = queryLastTemperatures;
                window.getTemperatureSummaryByZone = getTemperatureSummaryByZone;
                window.getCriticalOfflineDevices = getCriticalOfflineDevices;
                window.getDataUsageStats = getDataUsageStats;
                window.validateDeviceCounters = validateDeviceCounters;
                window.resetDeviceCounters = resetDeviceCounters;
                window.cleanupCache = cleanupCache;
                window.cleanupDeviceListeners = cleanupDeviceListeners;
                window.deviceData = deviceData;
                window.deviceList = deviceList;
                window.dataCache = dataCache;

                console.log('All device listeners started successfully');
                console.log('Available console commands:');
                console.log('- queryLastTemperatures(): Get current temperature readings');
                console.log('- getTemperatureSummaryByZone(): Get temperature summary by zone');
                console.log('- getCriticalOfflineDevices(): Get devices offline >30 minutes');
                console.log('- getDataUsageStats(): Get data usage and optimization statistics');
                console.log('- validateDeviceCounters(): Check counter accuracy');
                console.log('- resetDeviceCounters(): Reset and recalculate counters');
                console.log('- cleanupCache(): Manually cleanup cache');
                console.log('- cleanupDeviceListeners(): Cleanup all Firebase listeners');
                console.log('- deviceData: Access raw device data');
                console.log('- deviceList: Access current device list');
                console.log('- dataCache: Access cache data');
                console.log('📊 Data optimization is ACTIVE - Firebase usage minimized!');
                console.log('🔴 Red cards will appear for devices offline >30 minutes');
                
            } catch (error) {
                console.error('Error starting application:', error);
                const container = document.getElementById('device-cards-container');
                container.innerHTML = `
                    <div class="col-12 text-center">
                        <div class="alert alert-danger" role="alert">
                            <i class="fas fa-exclamation-circle fa-2x mb-3"></i>
                            <h4>เกิดข้อผิดพลาด</h4>
                            <p class="mb-0">ไม่สามารถเชื่อมต่อกับฐานข้อมูลได้: ${error.message}</p>
                        </div>
                    </div>
                `;
            }
        }

        // Start the application
        startApp();
    </script>
</body>

</html>